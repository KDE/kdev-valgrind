msgid ""
msgstr ""
"Project-Id-Version: kdeorg\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2022-08-05 00:43+0000\n"
"PO-Revision-Date: 2023-03-27 11:59\n"
"Last-Translator: \n"
"Language-Team: Chinese Simplified\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: kdeorg\n"
"X-Crowdin-Project-ID: 269464\n"
"X-Crowdin-Language: zh-CN\n"
"X-Crowdin-File: /kf5-trunk/messages/kdev-valgrind/kdevvalgrind.pot\n"
"X-Crowdin-File-ID: 5222\n"

#: config/globalconfigpage.cpp:45 launchmode.cpp:47 plugin.cpp:68
#: plugin.cpp:213 problemmodel.cpp:54 problemmodel.cpp:67
#, kde-format
msgid "Valgrind"
msgstr "Valgrind"

#: config/globalconfigpage.cpp:50
#, kde-format
msgid "Configure Valgrind Settings"
msgstr "配置 Valgrind 设置"

#. i18n: ectx: property (title), widget (QGroupBox, pathsGroupBox)
#: config/globalconfigpage.ui:29
#, kde-format
msgid "Valgrind executables"
msgstr "Valgrind 可执行文件"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:35
#, kde-format
msgid "Valgrind:"
msgstr "Valgrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:55
#, kde-format
msgid "callgrind_annotate:"
msgstr "callgrind_annotate:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:75
#, kde-format
msgid "cg_annotate:"
msgstr "cg_annotate:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox)
#: config/globalconfigpage.ui:98
#, kde-format
msgid "Visualizers executables"
msgstr "可视化器可执行文件"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:104
#, kde-format
msgid "KCachegrind:"
msgstr "KCachegrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:124
#, kde-format
msgid "Massif Visualizer:"
msgstr "Massif 可视化工具:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox_2)
#: config/globalconfigpage.ui:147
#, kde-format
msgid "Output"
msgstr "输出"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:153
#, kde-format
msgid ""
"<html><head/><body><p>Valgrind messages will be displayed in the output view "
"during analysis.</p><p>Useful for plugin debugging.</p></body></html>"
msgstr ""
"<html><head/><body><p>Valgrind 消息会在分析过程中显示在输出视图中。</p><p>有"
"助于插件调试。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:156
#, kde-format
msgid "Show valgrind output during analysis"
msgstr "分析时显示 Valgrind 输出"

#: core/job.cpp:138
#, kde-format
msgid "%1 Analysis (%2)"
msgstr "%1 分析 (%2)"

#: core/job.cpp:217
#, kde-format
msgid "Failed to start valgrind from \"%1\"."
msgstr "从“%1”启动 valgrind 失败。"

#: core/job.cpp:224
#, kde-format
msgid "Valgrind crashed."
msgstr "Valgrind 已崩溃。"

#: core/job.cpp:229
#, kde-format
msgid "Valgrind process timed out."
msgstr "Valgrind 进程超时。"

#: core/job.cpp:233
#, kde-format
msgid "Write to Valgrind process failed."
msgstr "写入 Valgrind 进程失败。"

#: core/job.cpp:237
#, kde-format
msgid "Read from Valgrind process failed."
msgstr "从 Valgrind 进程读取失败。"

#: core/job.cpp:255 core/job.cpp:301
#, kde-format
msgid "Please review your Valgrind launch configuration."
msgstr "请检查您的 Valgrind 启动配置。"

#: core/job.cpp:257
#, kde-format
msgid "Unknown Valgrind process error."
msgstr "未知的 Valgrind 进程错误。"

#: core/job.cpp:263 core/job.cpp:303 core/private/xmlparser.cpp:262
#: core/utils.cpp:124
#, kde-format
msgid "Valgrind Error"
msgstr "Valgrind 错误"

#: core/job.cpp:279
#, kde-format
msgid "Executing command: "
msgstr "执行命令： "

#: core/job.cpp:297
#, kde-format
msgid "Failed to execute the command:"
msgstr "执行命令失败："

#: core/private/common_configpage.cpp:30
#, kde-format
msgid "Valgrind Common Settings"
msgstr "Valgrind 通用设置"

#. i18n: ectx: property (text), widget (QLabel, numCallersLabel)
#: core/private/common_configpage.ui:22
#, kde-format
msgid "Display stac&k to depth:"
msgstr "最大显示堆栈深度 (&k)："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_numCallers)
#: core/private/common_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the maximum number of entries shown in stack "
"traces that identify program locations. Note that errors are commoned up "
"using only the top four function locations (the place in the current "
"function, and that of its three immediate callers). So this doesn't affect "
"the total number of errors reported.</p><p>The maximum value for this is "
"500. Note that higher settings will make Valgrind run a bit more slowly and "
"take a bit more memory, but can be useful when working with programs with "
"deeply-nested call chains.</p></body></html>"
msgstr ""
"<html><head/><body><p>指定在堆栈跟踪中显示程序位置的最多项目数。注意，错误仅"
"用最顶上的四个函数位置来分类（当前函数位置，以及它的三个直接调用者）。因此，"
"这不会影响总共报告的错误数量。</p><p>该值最大为 500。将此值设得更高会导致 "
"Valgrind 运行的稍微慢一点，并且使用略微更多的内存，但是在处理有非常深的调用链"
"的程序时可能有用。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, maxStackframeLabel)
#: core/private/common_configpage.ui:39
#, kde-format
msgid " Maximum size of a stack frame:"
msgstr " 堆栈帧最大尺寸："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maxStackframe)
#: core/private/common_configpage.ui:49
#, kde-format
msgid ""
"<html><head/><body><p>The maximum size of a stack frame. If the stack "
"pointer moves by more than this amount then Valgrind will assume that the "
"program is switching to a different stack.</p><p>You may need to use this "
"option if your program has large stack-allocated arrays. Valgrind keeps "
"track of your program's stack pointer. If it changes by more than the "
"threshold amount, Valgrind assumes your program is switching to a different "
"stack, and Memcheck behaves differently than it would for a stack pointer "
"change smaller than the threshold. Usually this heuristic works well. "
"However, if your program allocates large structures on the stack, this "
"heuristic will be fooled, and Memcheck will subsequently report large "
"numbers of invalid stack accesses. This option allows you to change the "
"threshold to a different value.</p><p>You should only consider use of this "
"option if Valgrind's debug output directs you to do so. In that case it will "
"tell you the new threshold you should specify.</p><p>In general, allocating "
"large structures on the stack is a bad idea, because you can easily run out "
"of stack space, especially on systems with limited memory or which expect to "
"support large numbers of threads each with a small stack, and also because "
"the error checking performed by Memcheck is more effective for heap-"
"allocated data than for stack-allocated data. If you have to use this "
"option, you may wish to consider rewriting your code to allocate on the heap "
"rather than on the stack.</p></body></html>"
msgstr ""
"<html><head/><body><p>堆栈帧的最大大小。如果您的堆栈指针移动了超过这个距离，"
"那么 Valgrind 会认为程序切换到了一个不同的堆栈。</p><p>如果您的程序使用大的堆"
"栈对其的数组，那您可能需要设置此选项。Valgrind 跟踪您程序的堆栈指针。如果它变"
"化了超过这个阈值，那么 Valgrind 会认为您的程序切换到了一个不同的堆栈，同时 "
"Memcheck 的行为也会和堆栈指针变化小于这个阈值时的行为不同。一般来说这个经验法"
"则效果不错。但是，如果您的程序在堆栈上分配大型结构，那这个经验法则可能会失"
"效，于是 Memcheck 会报告大量的非法堆栈访问。该选项允许您改变该阈值。</p><p>您"
"应当仅在 Valgrind 调试输出指导您这么做时考虑此选项。此时，它会告诉您应该设置"
"的新阈值。</p><p>一般来说，在堆栈上分配大型结构是个坏主意，因为您很容易耗尽堆"
"栈空间，特别是在那些内存有限或者设计成支持大量带有小堆栈的线程的系统。另外，"
"比起在堆栈上分配的数据，Memcheck 进行的错误检查也是对在堆上分配的数据更有效。"
"如果您必须要使用此选项，您可能需要考虑重写您的代码来在堆上进行分配，而不是在"
"堆栈上。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: core/private/common_configpage.ui:56
#, kde-format
msgid "&Extra parameters:"
msgstr "&额外参数:"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:82
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Valgrind stops reporting errors after "
"10,000,000 in total, or 1,000 different ones, have been seen. This is to "
"stop the error tracking machinery from becoming a huge performance overhead "
"in programs with many errors.</p></body></html>"
msgstr ""
"<html><head/><body><p>启用后，Valgrind 在显示了超过 10000000 个错误或超过 "
"1000 个不同的错误之后会停止报告错误。这么做是为了不让错误跟踪系统在程序有很多"
"错误的情况下成为一个可观的性能瓶颈。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:85
#, kde-format
msgid "Limit errors if too many"
msgstr "避免显示过多错误"

#: core/private/xmlparser.cpp:258
#, kde-format
msgid "Valgrind XML Parsing: error at line %1, column %2: %3"
msgstr "Valgrind XML 解析：错误位于 行 %1，列 %2：%3"

#: core/utils.cpp:47
#, kde-format
msgid "Instruction Fetch"
msgstr "指令获取"

#: core/utils.cpp:48
#, kde-format
msgid "Data Read Access"
msgstr "数据读访问"

#: core/utils.cpp:49
#, kde-format
msgid "Data Write Access"
msgstr "数据写访问"

#: core/utils.cpp:50
#, kde-format
msgid "L1 Instr. Fetch Miss"
msgstr "L1 指令获取失败"

#: core/utils.cpp:51
#, kde-format
msgid "L1 Data Read Miss"
msgstr "L1 数据读取失败"

#: core/utils.cpp:52
#, kde-format
msgid "L1 Data Write Miss"
msgstr "L1 数据写入失败"

#: core/utils.cpp:53
#, kde-format
msgid "LL Instr. Fetch Miss"
msgstr "LL 指令获取失败"

#: core/utils.cpp:54
#, kde-format
msgid "LL Data Read Miss"
msgstr "LL 数据读取失败"

#: core/utils.cpp:55
#, kde-format
msgid "LL Data Write Miss"
msgstr "LL 数据写入失败"

#: core/utils.cpp:57
#, kde-format
msgid "Conditional Branch"
msgstr "条件分支"

#: core/utils.cpp:58
#, kde-format
msgid "Mispredicted Cond. Branch"
msgstr "预测失败的条件分支"

#: core/utils.cpp:59
#, kde-format
msgid "Indirect Branch"
msgstr "间接分支"

#: core/utils.cpp:60
#, kde-format
msgid "Mispredicted Ind. Branch"
msgstr "预测失败的间接分支"

#: core/utils.cpp:116
#, kde-format
msgid "Failed to start visualizer from \"%1\"."
msgstr "无法从“%1”启动可视化工具。"

#: core/utils.cpp:118
#, kde-format
msgid "Check your settings and install the visualizer if necessary."
msgstr "检查您的设置，如有需要，安装可视化工具。"

#: core/utils.cpp:120
#, kde-format
msgid "Error during visualizer execution:"
msgstr "可视化工具运行时出现错误："

#: core/widgets/menubutton.cpp:95 tools/memcheck/memcheck_configpage.cpp:64
#, kde-format
msgid "none"
msgstr "无可用密钥"

#: core/widgets/menubutton.cpp:98
#, kde-format
msgid "all"
msgstr "全部"

#. i18n: ectx: Menu (valgrind)
#: kdevvalgrind.rc:6
#, kde-format
msgid "Run Valgrind Analysis"
msgstr "运行 Valgrind 分析"

#: plugin.cpp:79
#, kde-format
msgid "Run %1"
msgstr "运行 %1"

#: problemmodel.cpp:68
#, kde-format
msgctxt "@info:tooltip"
msgid "Re-Run %1 Analysis for Current Launch Configuration"
msgstr "以当前启动配置重新运行 %1 分析"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of cache access and "
"miss counts.</p></body></html>"
msgstr ""
"<html><head/><body><p>启用或禁用缓存访问与未命中计数。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:26
#: tools/callgrind/callgrind_configpage.ui:26
#, kde-format
msgid "Cache simulation"
msgstr "缓存模拟"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:36
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of branch instruction "
"and misprediction counts. By default this is disabled as it slows Cachegrind "
"down by approximately 25%. Note that you cannot specify <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--cache-sim=no</"
"span> and <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--branch-sim=no</span> together, as that would leave "
"Cachegrind with no information to collect.</p></body></html>"
msgstr ""
"<html><head/><body><p>启用或禁用对分支指令和错误预测次数的收集。默认情况下，"
"因为这会使 Cachegrind 速度降低大约25%，这会被禁用。注意您不能同时指定 <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"cache-sim=no</span> 和 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--branch-sim=no</span>，因为这会使得 "
"Cachegrind 没有需要收集的信息。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:39
#: tools/callgrind/callgrind_configpage.ui:39
#, kde-format
msgid "Branch simulation"
msgstr "分支模拟"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/cachegrind/cachegrind_configpage.ui:49
#, kde-format
msgid ""
"You cannot disable both cache and branch simulation, as that would leave "
"Cachegrind with no information to collect."
msgstr ""
"您不能同时禁用缓存和分支模拟，因为这将使得 Cachegrind 没有需要收集的信息。"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:74
#: tools/callgrind/callgrind_configpage.ui:58 tools/drd/drd_configpage.ui:51
#: tools/helgrind/helgrind_configpage.ui:46
#, kde-format
msgid "Extra parameters:"
msgstr "额外参数:"

#. i18n: ectx: property (text), widget (QLabel, cgAnnotateArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:91
#, kde-format
msgid "cg_annotate parameters:"
msgstr "cg_annotate 参数："

#: tools/cachegrind/cachegrind_model.cpp:155
#: tools/callgrind/callgrind_model.cpp:289
#, kde-format
msgid "Function"
msgstr "函数"

#: tools/cachegrind/cachegrind_tool.cpp:35
#, kde-format
msgid "Cachegrind"
msgstr "Cachegrind"

#: tools/cachegrind/cachegrind_tool.cpp:36
#, kde-format
msgid "Cachegrind (Cache and Branch-Prediction Profiler)"
msgstr "Cachegrind (缓存和分支预测分析器)"

#. i18n: ectx: property (placeholderText), widget (QLineEdit, searchEdit)
#: tools/cachegrind/cachegrind_view.ui:31 tools/callgrind/callgrind_view.ui:40
#, kde-format
msgid "Search..."
msgstr "搜索..."

#. i18n: ectx: property (text), widget (QCheckBox, percenageValues)
#: tools/cachegrind/cachegrind_view.ui:41 tools/callgrind/callgrind_view.ui:53
#, kde-format
msgid "Percentage values"
msgstr "百分比"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/callgrind/callgrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do full cache simulation. By "
"default, only instruction read accesses will be counted (&quot;Ir&quot;). "
"With cache simulation, further event counters are enabled: </p><p>Cache "
"misses on instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), </p><p>data "
"read accesses (&quot;Dr&quot;) and related cache misses (&quot;D1mr&quot;/"
"&quot;DLmr&quot;), </p><p>data write accesses (&quot;Dw&quot;) and related "
"cache misses (&quot;D1mw&quot;/&quot;DLmw&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>指定是否要进行完整的缓存模拟。默认情况下，只有指令读取"
"访问会被计数（&quot;Ir&quot;）。如果进行缓存模拟，那么会启用其他的时间计数"
"器：</p><p>指令读取时缓存未命中（&quot;I1mr&quot;/&quot;&quot;ILmr&quot;），"
"</p><p>数据读取访问（&quot;Dr&quot;）与相关的缓存未命中（&quot;D1mr&quot;/"
"&quot;DLmr&quot;），</p><p>数据写访问（&quot;Dw&quot;）与相关的缓存未命中"
"（&quot;D1mw&quot;/&quot;DLmw&quot;）。</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/callgrind/callgrind_configpage.ui:36
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do branch prediction "
"simulation. Further event counters are enabled: Number of executed "
"conditional branches and related predictor misses (&quot;Bc&quot;/&quot;"
"Bcm&quot;), executed indirect jumps and related misses of the jump address "
"predictor (&quot;Bi&quot;/&quot;Bim&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>指定是否要进行分支预测模拟。这会启用更多的事件计数器："
"执行的条件分支的数量和相关的预测失误（&quot;Bc&quot;/&quot;Bcm&quot;），执行"
"的间接跳转和相关的跳转地址预测失误（&quot;Bi&quot;/&quot;Bim&quot;）。</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QLabel, callgrindAnnotateArgsLabel)
#: tools/callgrind/callgrind_configpage.ui:75
#, kde-format
msgid "callgrind_annotate parameters:"
msgstr "callgrind_annotate 参数："

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchKCachegrind)
#: tools/callgrind/callgrind_configpage.ui:101
#, kde-format
msgid "Launch KCachegrind after analysis finish"
msgstr "分析完成后启动 KCachegrind"

#: tools/callgrind/callgrind_model.cpp:286
#: tools/callgrind/callgrind_model.cpp:375
#, kde-format
msgid "Incl."
msgstr "包含"

#: tools/callgrind/callgrind_model.cpp:287
#: tools/callgrind/callgrind_model.cpp:376
#, kde-format
msgid "Self"
msgstr "自身"

#: tools/callgrind/callgrind_model.cpp:288
#, kde-format
msgid "Called"
msgstr "已调用"

#: tools/callgrind/callgrind_model.cpp:374
#, kde-format
msgid "Event"
msgstr "事件"

#: tools/callgrind/callgrind_model.cpp:377
#, kde-format
msgid "Short"
msgstr "短"

#: tools/callgrind/callgrind_model.cpp:499
#, kde-format
msgid "%1 per call"
msgstr "%1 每次调用"

#: tools/callgrind/callgrind_model.cpp:500
#, kde-format
msgid "Count"
msgstr "Count"

#: tools/callgrind/callgrind_model.cpp:503
#, kde-format
msgid "Caller"
msgstr "调用方"

#: tools/callgrind/callgrind_model.cpp:505
#, kde-format
msgid "Callee"
msgstr "被调用方"

#: tools/callgrind/callgrind_tool.cpp:35
#, kde-format
msgid "Callgrind"
msgstr "Callgrind"

#: tools/callgrind/callgrind_tool.cpp:36
#, kde-format
msgid "Callgrind (Call-Graph Generating Cache and Branch Prediction Profiler)"
msgstr "Callgrind（可生成调用图的缓存和分支预测分析器）"

#. i18n: ectx: property (text), widget (QPushButton, launchKCachegrindButton)
#: tools/callgrind/callgrind_view.ui:63
#, kde-format
msgid "Launch KCachegrind"
msgstr "启动 KCachegrind"

#. i18n: ectx: attribute (title), widget (QWidget, events)
#: tools/callgrind/callgrind_view.ui:91
#, kde-format
msgid "Events"
msgstr "事件"

#. i18n: ectx: attribute (title), widget (QWidget, callers)
#: tools/callgrind/callgrind_view.ui:117
#, kde-format
msgid "Direct callers"
msgstr "直接调用方"

#. i18n: ectx: attribute (title), widget (QWidget, callees)
#: tools/callgrind/callgrind_view.ui:149
#, kde-format
msgid "Direct callees"
msgstr "直接被调用方"

#. i18n: ectx: attribute (title), widget (QWidget, location)
#: tools/callgrind/callgrind_view.ui:187
#, kde-format
msgid "Location"
msgstr "住址"

#. i18n: ectx: property (text), widget (QLabel, binaryTitle)
#: tools/callgrind/callgrind_view.ui:199
#, kde-format
msgid "Binary file:"
msgstr "二进制文件："

#. i18n: ectx: property (text), widget (QLabel, sourceTitle)
#: tools/callgrind/callgrind_view.ui:232
#, kde-format
msgid "Source file(s):"
msgstr "源文件："

#. i18n: ectx: property (text), widget (QLabel, joinListVolLabel)
#: tools/drd/drd_configpage.ui:20
#, kde-format
msgid "Joined threads memory access list volume:"
msgstr "已会合线程内存访问列表大小："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_joinListVol)
#: tools/drd/drd_configpage.ui:30
#, kde-format
msgid ""
"<html><head/><body><p>Data races that occur between a statement at the end "
"of one thread and another thread can be missed if memory access information "
"is discarded immediately after a thread has been joined. This option allows "
"to specify for how many joined threads memory access information should be "
"retained.</p></body></html>"
msgstr ""
"<html><head/><body><p>如果在与一个线程会合后将其内存访问信息立即丢弃的话，那"
"么在该线程结束时运行的语句和另一个线程之间发生的数据竞争性访问可能会被忽略。"
"此选项允许您指定要保留多少已会合的线程的内存访问信息。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, segmentMergingIntervalLabel)
#: tools/drd/drd_configpage.ui:37
#, kde-format
msgid "Segment merging interval:"
msgstr "段合并间隔："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_segmentMergingInterval)
#: tools/drd/drd_configpage.ui:44
#, kde-format
msgid ""
"<html><head/><body><p>Perform segment merging only after the specified "
"number of new segments have been created. This is an advanced configuration "
"option that allows to choose whether to minimize DRD's memory usage by "
"choosing a low value or to let DRD run faster by choosing a slightly higher "
"value. The optimal value for this parameter depends on the program being "
"analyzed. The default value works well for most programs.</p></body></html>"
msgstr ""
"<html><head/><body><p>仅在创建指定数量的新段后进行段合并。这是一个高级配置选"
"项，可用于选择是否要通过使用一个较低的值来最小化 DRD 的内存使用，还是要选择一"
"个稍高的值来让 DRD 运行得更快速。该选项的最优值依赖于正在分析的程序。默认值对"
"大多数程序工作良好。</p></body></html>"

#. i18n: ectx: attribute (title), widget (QWidget, tab)
#: tools/drd/drd_configpage.ui:75
#, kde-format
msgid "Common options"
msgstr "常用选项"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:81
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether DRD detects data races on stack "
"variables. Verifying stack variables is disabled by default because most "
"programs do not share stack variables over threads.</p></body></html>"
msgstr ""
"<html><head/><body><p>控制 DRD 是否检测堆栈变量的数据竞争性访问。默认情况下，"
"对堆栈变量的验证被禁用，因为大多数程序不在线程间共享堆栈变量。</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:84
#, kde-format
msgid "Detect data races on stack variables"
msgstr "检测堆栈变量的数据竞争性访问"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:91
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report only the first data race that has "
"been detected on a memory location or all data races that have been detected "
"on a memory location.</p></body></html>"
msgstr ""
"<html><head/><body><p>是否要仅报告在某个内存位置检测到的第一个数据竞争性访"
"问，还是要报告所有在此位置检测到的数据竞争性访问。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:94
#, kde-format
msgid "Report only the first data race"
msgstr "仅报告第一次数据竞争性访问"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:104
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report races between accessing memory and "
"freeing memory. Enabling this option may cause DRD to run slightly slower. "
"Notes:</p><p>Don't enable this option when using custom memory allocators "
"that use the <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">VG_USERREQ__MALLOCLIKE_BLOCK</span> and <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span> because that would result in false "
"positives. </p><p>Don't enable this option when using reference-counted "
"objects because that will result in false positives, even when that code has "
"been annotated properly with <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE</span> and <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER</span>. See e.g. the output of the following "
"command for an example: <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">valgrind --tool=drd --free-is-write=yes drd/"
"tests/annotate_smart_pointer</span>.</p></body></html>"
msgstr ""
"<html><head/><body><p>是否要报告访问内存和释放内存之间的竞争性访问。开启此选"
"项可能会使得 DRD 运行得稍微慢一点。注意：</p><p>不要在使用启用了 <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__MALLOCLIKE_BLOCK</span> 和 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span> 的自定义内存分配器时开启此选项，因为这会"
"导致结果中出现假阳性。</p><p>不要在使用引用计数的对象时开启此选项，因为这也会"
"导致假阳性，即使程序代码被正确地用 <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE</span> 和 "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER</span> 修饰过了。以下命令的输出就是一个例子：<span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">valgrind --tool=drd --free-is-write=yes drd/tests/annotate_smart_pointer</"
"span>。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:107
#, kde-format
msgid "Report races between accessing and freeing memory"
msgstr "报告访问和释放内存间的竞争性访问"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_signal</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_broadcast</span> where "
"the mutex associated with the signal through <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">pthread_cond_wait</"
"span> or <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">pthread_cond_timed_wait</span> is not locked at the time the "
"signal is sent. Sending a signal without holding a lock on the associated "
"mutex is a common programming error which can cause subtle race conditions "
"and unpredictable behavior. There exist some uncommon synchronization "
"patterns however where it is safe to send a signal without holding a lock on "
"the associated mutex.</p></body></html>"
msgstr ""
"<html><head/><body><p>是否要报告对 <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_signal</span> 和 <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_broadcast</span> 的调用，如果在用它们发送信号时，通过 <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_wait</span> 或 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">pthread_cond_timed_wait</span> 和这个信号相"
"关联的互斥锁并没有被锁住。在没有持有相关的互斥锁时发送信号是一个常见的编程错"
"误，这可能会导致微妙的竞争性访问条件以及不可预测的行为。然而，在某些少见的同"
"步模式中，不持有相关的互斥锁而直接发送信号是安全的。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:117
#, kde-format
msgid "Report calls to unlocked signals"
msgstr "报告对未加锁的信号量的调用"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:124
#, kde-format
msgid ""
"<html><head/><body><p>Controls segment merging. Segment merging is an "
"algorithm to limit memory usage of the data race detection algorithm. "
"Disabling segment merging may improve the accuracy of the so-called 'other "
"segments' displayed in race reports but can also trigger an out of memory "
"error.</p></body></html>"
msgstr ""
"<html><head/><body><p>控制段合并。段合并是一个用于限制数据竞争性访问检测算法"
"内存用量的方法。禁止段合并可能会提升竞争性访问报告中标注为“其它段”的部分的精"
"确度，但是也可能会导致内存不足的问题。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:127
#, kde-format
msgid "Segment merging"
msgstr "段合并"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:134
#, kde-format
msgid ""
"<html><head/><body><p>Show conflicting segments in race reports. Since this "
"information can help to find the cause of a data race, this option is "
"enabled by default. Disabling this option makes the output of DRD more "
"compact.</p></body></html>"
msgstr ""
"<html><head/><body><p>在竞争性访问报告中显示冲突的段。因为此信息可能帮助您找"
"到数据竞争性访问的原因，该选项默认开启。禁止该选项能让 DRD 的输出更紧凑。</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:137
#, kde-format
msgid "Show conflicting segments"
msgstr "显示冲突段"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:144
#, kde-format
msgid ""
"<html><head/><body><p>Print stack usage at thread exit time. When a program "
"creates a large number of threads it becomes important to limit the amount "
"of virtual memory allocated for thread stacks. This option makes it possible "
"to observe how much stack memory has been used by each thread of the client "
"program.</p><p>Note: the DRD tool itself allocates some temporary data on "
"the client thread stack. The space necessary for this temporary data must be "
"allocated by the client program when it allocates stack memory, but is not "
"included in stack usage reported by DRD.</p></body></html>"
msgstr ""
"<html><head/><body><p>在线程退出时显示堆栈用量。如果一个程序创建了大量的线"
"程，那么限制分配给线程堆栈的虚拟内存的量就显得很重要。该选项让您可以观察到客"
"户程序每个线程使用了多少堆栈内存。</p><p>注意：DRD 工具本身会在客户线程堆栈上"
"分配一些临时数据。客户程序分配堆栈内存时必须也给这些临时数据分配空间，但是它"
"们不会被计入 DRD 显示的堆栈使用报告中。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:147
#, kde-format
msgid "Show stack usage"
msgstr "显示堆栈使用情况"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:154
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses DRD as "
"it assumes there is some false ordering in place between creator and created "
"thread; and therefore many types of race conditions in the application would "
"not be reported. To prevent such false ordering, this command line option is "
"set to <span style=\" font-family:'Monospace';\">yes</span> by default on "
"Solaris. All activity (loads, stores, client requests) is therefore ignored "
"during:</p><p>* pthread_create() call in the creator thread </p><p>* thread "
"creation phase (stack and TLS setup) in the created thread</p></body></html>"
msgstr ""
"<html><head/><body><p>控制是否应忽略线程创建过程中的所有活动。默认仅在 "
"Solaris 上启用。比起其他操作系统，Solaris 提供更高的吞吐率、并行化率和可扩展"
"性，但是代价是更精细化的加锁操作。例如当线程在 glibc 下创建时，整个线程设置过"
"程被一个大锁保护，而 Solaris libc 使用多个精细的锁。这使得创建线程能尽快恢复"
"其原有活动，而将包括堆栈和 TLS 设置过程留给新创建的线程完成。这种情况会使 "
"DRD 陷入混乱，因为它会认为创建者和被创建的线程之间有某种虚假的次序。作为结"
"果，许多种应用程序中的竞争条件不会被报告。为了避免这种对虚假次序的认知，该命"
"令行参数默认在 Solaris 上被设置为<span style=\" font-family:'Monospace';"
"\">yes</span>。所有活动（读取，写入，客户请求）都会在以下过程中被忽略：</"
"p><p>* 创建者线程的 pthread_create() 调用中 </p><p>* 被创建线程的线程创建阶段"
"（堆栈和 TLS 设置）</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:157 tools/helgrind/helgrind_configpage.ui:105
#, kde-format
msgid "Ignore thread creation"
msgstr "忽略线程创建"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showInstructionPointer)
#: tools/drd/drd_configpage.ui:171 tools/helgrind/helgrind_configpage.ui:132
#: tools/memcheck/memcheck_configpage.ui:210
#, kde-format
msgid "Show stack frame instruction pointer value"
msgstr "显示堆栈帧指令指针的值"

#. i18n: ectx: attribute (title), widget (QWidget, tracesTab)
#: tools/drd/drd_configpage.ui:192
#, kde-format
msgid "Trace options"
msgstr "追踪选项"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:198
#, kde-format
msgid ""
"<html><head/><body><p>Trace all memory allocations and deallocations. May "
"produce a huge amount of output.</p></body></html>"
msgstr ""
"<html><head/><body><p>追踪所有内存分配和释放。可能会产生大量的输出。</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:201
#, kde-format
msgid "Trace memory allocations/deallocations"
msgstr "追踪内存分配/释放"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:208
#, kde-format
msgid "<html><head/><body><p>Trace all barrier activity.</p></body></html>"
msgstr "<html><head/><body><p>追踪所有同步屏障活动。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:211
#, kde-format
msgid "Trace barrier activity"
msgstr "追踪同步屏障活动"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:218
#, kde-format
msgid ""
"<html><head/><body><p>Trace all condition variable activity.</p></body></"
"html>"
msgstr "<html><head/><body><p>追踪所有条件变量活动。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:221
#, kde-format
msgid "Trace condition variable activity"
msgstr "追踪条件变量活动"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:228
#, kde-format
msgid ""
"<html><head/><body><p>Trace all thread creation and all thread termination "
"events.</p></body></html>"
msgstr ""
"<html><head/><body><p>追踪所有线程创建和线程终止事件。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:231
#, kde-format
msgid "Trace thread creation/termination events"
msgstr "追踪线程创建/终止事件"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:238
#, kde-format
msgid ""
"<html><head/><body><p>Trace execution of the <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE()</span>, <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER()</span> and "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span> client requests.</p></body></html>"
msgstr ""
"<html><head/><body><p>追踪带有 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE()</span>，<span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER()</span> 和 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span> 标记的客户请求的执行。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:241
#, kde-format
msgid "Trace execution of \"ANNOTATE_HAPPENS\" requests"
msgstr "追踪带有“ANNOTATE_HAPPENS”标记请求的执行"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:248
#, kde-format
msgid "<html><head/><body><p>Trace all mutex activity.</p></body></html>"
msgstr "<html><head/><body><p>追踪所有的互斥锁活动。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:251
#, kde-format
msgid "Trace mutex activity"
msgstr "追踪互斥锁活动"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:258
#, kde-format
msgid ""
"<html><head/><body><p>Trace all reader-writer lock activity.</p></body></"
"html>"
msgstr "<html><head/><body><p>追踪所有读写锁活动。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:261
#, kde-format
msgid "Trace reader-writer lock activity"
msgstr "追踪读写锁活动"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:268
#, kde-format
msgid "<html><head/><body><p>Trace all semaphore activity.</p></body></html>"
msgstr "<html><head/><body><p>追踪所有信号量活动。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:271
#, kde-format
msgid "Trace semaphore activity"
msgstr "追踪信号量活动"

#: tools/drd/drd_tool.cpp:35
#, kde-format
msgid "DRD"
msgstr "DRD"

#: tools/drd/drd_tool.cpp:36
#, kde-format
msgid "DRD (Thread Error Detector)"
msgstr "DRD (线程错误检测器)"

#: tools/helgrind/helgrind_configpage.cpp:36
#, kde-format
msgid "Full"
msgstr "完全"

#: tools/helgrind/helgrind_configpage.cpp:37
#, kde-format
msgid "Approx"
msgstr "近似"

#: tools/helgrind/helgrind_configpage.cpp:38
#, kde-format
msgid "None"
msgstr "未分组"

#. i18n: ectx: property (text), widget (QLabel, historyLevelLabel)
#: tools/helgrind/helgrind_configpage.ui:22
#, kde-format
msgid "History level:"
msgstr "历史级别："

#. i18n: ectx: property (text), widget (QLabel, conflictCacheSizeLabel)
#: tools/helgrind/helgrind_configpage.ui:29
#, kde-format
msgid "Conflict cache size:"
msgstr "冲突缓存大小："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_conflictCacheSize)
#: tools/helgrind/helgrind_configpage.ui:39
#, kde-format
msgid ""
"<html><head/><body><p>This flag only has any effect at <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
"level=full</span>.</p><p>Information about &quot;old&quot; conflicting "
"accesses is stored in a cache of limited size, with LRU-style management. "
"This is necessary because it isn't practical to store a stack trace for "
"every single memory access made by the program. Historical information on "
"not recently accessed locations is periodically discarded, to free up space "
"in the cache.</p><p>This option controls the size of the cache, in terms of "
"the number of different memory addresses for which conflicting access "
"information is stored. If you find that Helgrind is showing race errors with "
"only one stack instead of the expected two stacks, try increasing this value."
"</p><p>The minimum value is 10,000 and the maximum is 30,000,000 (thirty "
"times the default value). Increasing the value by 1 increases Helgrind's "
"memory requirement by very roughly 100 bytes, so the maximum value will "
"easily eat up three extra gigabytes or so of memory.</p></body></html>"
msgstr ""
"<html><head/><body><p>该选项仅当 <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--history-level=full</span> 时有效。</"
"p><p>关于 &quot;旧的&quot; 冲突性访问的信息被保存在一个大小有限的缓存中，该缓"
"存以 LRU（最近最少使用）方法管理。因为保存程序每次内存访问时的堆栈跟踪并不现"
"实，这么做是有必要的。最近没有访问过的位置的历史信息会被周期性地丢弃，用以给"
"缓存腾出空间。</p><p>该选项控制了缓存的大小，以被保存了冲突访问信息的不同内存"
"地址数量计。如果您发现 Helgrind 在显示竞争性访问错误时仅显示了一个调用堆栈，"
"而不是预期的两个，那么您可以尝试增大此值。</p><p>最小值为 10,000，最大值为 "
"30,000,000（默认值的30倍）。将此值增加1大约会让 Helgrind 的内存需求增加100字"
"节，因此使用最大值会轻易地额外占用三千兆字节（3GB）内存。</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:78
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (the default), Helgrind performs lock "
"order consistency checking. For some buggy programs, the large number of "
"lock order errors reported can become annoying, particularly if you're only "
"interested in race errors. You may therefore find it helpful to disable lock "
"order checking.</p></body></html>"
msgstr ""
"<html><head/><body><p>如果启用（默认），Helgrind 会进行锁顺序一致性检查。对一"
"些有问题的程序，报告出来的大量锁顺序错误可能会令人烦躁，特别是如果您只关心竞"
"争性访问错误。这种情况下，禁止锁顺序检查可能会对您有所帮助。</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:81
#, kde-format
msgid "Track lock orders"
msgstr "追踪锁次序"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:92
#, kde-format
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">By default Helgrind checks "
"all data memory accesses made by your program. This flag enables you to skip "
"checking for accesses to thread stacks (local variables). This can improve "
"performance, but comes at the cost of missing races on stack-allocated data."
"</p></body></html>"
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">默认情况下 Helgrind 检查您"
"的程序进行的所有的内存访问。该选项允许您跳过对线程堆栈（本地变量）的访问。 这"
"可以提高性能，但是代价是您可能会错过对堆栈上分配的数据的竞争性访问。</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:95
#, kde-format
msgid "Check stack refs"
msgstr "检查堆栈引用"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/helgrind/helgrind_configpage.ui:102
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses "
"Helgrind as it assumes there is some false ordering in place between creator "
"and created thread; and therefore many types of race conditions in the "
"application would not be reported. To prevent such false ordering, this "
"command line option is set to yes by default on Solaris. All activity "
"(loads, stores, client requests) is therefore ignored during:</p><p>* "
"pthread_create() call in the creator thread</p><p>* thread creation phase "
"(stack and TLS setup) in the created thread</p><p>Also new memory allocated "
"during thread creation is untracked, that is race reporting is suppressed "
"there. DRD does the same thing implicitly. This is necessary because Solaris "
"libc caches many objects and reuses them for different threads and that "
"confuses Helgrind.</p></body></html>"
msgstr ""
"<html><head/><body><p>控制是否应忽略线程创建过程中的所有活动。默认仅在 "
"Solaris 上启用。比起其他操作系统，Solaris 提供更高的吞吐率、并行化率和可扩展"
"性，但是代价是更精细化的加锁操作。例如当线程在 glibc 下创建时，整个线程设置过"
"程被一个大锁保护，而 Solaris libc 使用多个精细的锁。这使得创建线程能尽快恢复"
"其原有活动，而将包括堆栈和 TLS 设置过程留给新创建的线程完成。这种情况会使 "
"Helgrind 陷入混乱，因为它会认为创建者和被创建的线程之间有某种虚假的次序。作为"
"结果，许多种应用程序中的竞争条件不会被报告。为了避免这种对虚假次序的认知，该"
"命令行参数默认在 Solaris 上被设置为 yes。所有活动（读取，写入，客户请求）都会"
"在以下过程中被忽略：</p><p>* 创建者线程的 pthread_create() 调用中 </p><p>* 被"
"创建线程的线程创建阶段（堆栈和 TLS 设置）</p><p>另外，线程创建时分配的内存不"
"会被追踪，也就是说在这些区域竞争性访问不会被报告。DRD 会隐式地进行相同的操"
"作。之所以需要这么干，是因为 Solaris libc 会缓存大量的对象并且在不同线程间重"
"用它们，而这会令 Helgrind 陷入混乱。</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:115
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (not the default), Helgrind treats "
"freeing of heap memory as if the memory was written immediately before the "
"free. This exposes races where memory is referenced by one thread, and freed "
"by another, but there is no observable synchronization event to ensure that "
"the reference happens before the free.</p><p>This functionality is new in "
"Valgrind 3.7.0, and is regarded as experimental. It is not enabled by "
"default because its interaction with custom memory allocators is not well "
"understood at present. User feedback is welcomed.</p></body></html>"
msgstr ""
"<html><head/><body><p>如果启用（非默认），Helgrind 会在堆内存被释放时假装这些"
"内存在释放前刚被写入过。这可以检测到类似这样的竞争性访问：如果内存被一个线程"
"引用，同时被另一个线程释放，但是它们之间没有可见的同步事件来保证引用一定在释"
"放前发生。</p><p>这是一个 Valgrind 3.7.0 中的新功能，还是实验性的。之所以它默"
"认不被启用，是因为现在对它和自定义内存分配器之间的交互还没有一个很好的理解。"
"欢迎用户反馈。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:118
#, kde-format
msgid "Free is write (experimental)"
msgstr "将释放视作写入 (实验性)"

#: tools/helgrind/helgrind_tool.cpp:35
#, kde-format
msgid "Helgrind"
msgstr "Helgrind"

#: tools/helgrind/helgrind_tool.cpp:36
#, kde-format
msgid "Helgrind (Thread Error Detector)"
msgstr "Helgrind (线程错误检测器)"

#: tools/massif/massif_configpage.cpp:39
#, kde-format
msgid "CPU instructions"
msgstr "CPU 指令"

#: tools/massif/massif_configpage.cpp:40
#, kde-format
msgid "Milliseconds"
msgstr "毫秒"

#: tools/massif/massif_configpage.cpp:41
#, kde-format
msgid "Bytes allocated"
msgstr "已分配字节"

#. i18n: ectx: property (text), widget (QLabel, timeUnitLabel)
#: tools/massif/massif_configpage.ui:25
#, kde-format
msgid "Time unit:"
msgstr "时间单位："

#. i18n: ectx: property (text), widget (QLabel, snapshotTreeDepthLabel)
#: tools/massif/massif_configpage.ui:32
#, kde-format
msgid "Snapshot tree depth:"
msgstr "快照树深度："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_snapshotTreeDepth)
#: tools/massif/massif_configpage.ui:42
#, kde-format
msgid ""
"<html><head/><body><p>Maximum depth of the allocation trees recorded for "
"detailed snapshots. Increasing it will make Massif run somewhat more slowly, "
"use more memory, and produce bigger output files.</p></body></html>"
msgstr ""
"<html><head/><body><p>详细快照中记录的分配树的最大深度。增加它会使得 Massif "
"运行得更慢一些，使用更多内存，还会产生更大的输出文件。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, thresholdLabel)
#: tools/massif/massif_configpage.ui:49
#, kde-format
msgid "Threshold:"
msgstr "界限："

#. i18n: ectx: property (text), widget (QLabel, peakInaccuracyLabel)
#: tools/massif/massif_configpage.ui:59
#, kde-format
msgid "Peak inaccuracy:"
msgstr "最高不精确度："

#. i18n: ectx: property (text), widget (QLabel, maximumSnapshotsLabel)
#: tools/massif/massif_configpage.ui:69
#, kde-format
msgid "Maximum snapshots:"
msgstr "最多快照数："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maximumSnapshots)
#: tools/massif/massif_configpage.ui:79
#, kde-format
msgid ""
"<html><head/><body><p>The maximum number of snapshots recorded. If set to N, "
"for all programs except very short-running ones, the final number of "
"snapshots will be between N/2 and N.</p></body></html>"
msgstr ""
"<html><head/><body><p>最多记录的快照数。如果设置为 N，那对除了运行时间非常短"
"的程序以外的所有程序，最后快照数量会在 N/2 和 N 之间。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, detailedSnapshotsFrequencyLabel)
#: tools/massif/massif_configpage.ui:86
#, kde-format
msgid "Detailed snapshot frequency:"
msgstr "详细快照频率："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_detailedSnapshotsFrequency)
#: tools/massif/massif_configpage.ui:96
#, kde-format
msgid ""
"<html><head/><body><p>Frequency of detailed snapshots. With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--detailed-"
"freq=1</span>, every snapshot is detailed.</p></body></html>"
msgstr ""
"<html><head/><body><p>详细快照的频率。如果设置 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--detailed-freq=1</"
"span>，那么每个快照都是详细的。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/massif/massif_configpage.ui:103
#: tools/memcheck/memcheck_configpage.ui:121
#, kde-format
msgid "E&xtra parameters:"
msgstr "额外参数(&X)："

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_threshold)
#: tools/massif/massif_configpage.ui:123
#, kde-format
msgid ""
"<html><head/><body><p>The significance threshold for heap allocations, as a "
"percentage of total memory size. Allocation tree entries that account for "
"less than this will be aggregated. Note that this should be specified in "
"tandem with ms_print's option of the same name.</p></body></html>"
msgstr ""
"<html><head/><body><p>堆分配的显著性阈值，以总内存大小的百分比计。分配树中所"
"占大小小于这个阈值的项目会被聚合。注意这个选项应该被和 ms_print 的同名选项一"
"同指定。</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_peakInaccuracy)
#: tools/massif/massif_configpage.ui:136
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Massif does not necessarily record the actual global "
"memory allocation peak; by default it records a peak only when the global "
"memory allocation size exceeds the previous peak by at least 1.0%. This is "
"because there can be many local allocation peaks along the way, and doing a "
"detailed snapshot for every one would be expensive and wasteful, as all but "
"one of them will be later discarded. This inaccuracy can be changed (even to "
"0.0%) via this option, but Massif will run drastically slower as the number "
"approaches zero.</p></body></html>"
msgstr ""
"<html><head/><body><p>Massif 未必会报告实际上的全局内存使用峰值；默认情况下它"
"只会在全局内存分配大小至少超过之前峰值的1.0%时才会记录一个新的峰值。这是因为"
"在此过程中可能会有很多本地分配导致的峰值。如果对每一个都进行详细的快照，可能"
"会过于昂贵且浪费，因为最后除了其中一个以外，其它都会被丢弃。这个不精确性可以"
"通过此选项被改变（甚至降低到0.0%），但是随着这个值接近零，Massif 的运行速度会"
"大幅减缓。</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:158
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether heap profiling should be done.</p></"
"body></html>"
msgstr "<html><head/><body><p>指定是否要进行堆分析。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:161
#, kde-format
msgid "Profile heap"
msgstr "分析堆"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:171
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether stack profiling should be done. This "
"option slows Massif down greatly, and so is off by default. Note that Massif "
"assumes that the main stack has size zero at start-up. This is not true, but "
"doing otherwise accurately is difficult. Furthermore, starting at zero "
"better indicates the size of the part of the main stack that a user program "
"actually has control over.</p></body></html>"
msgstr ""
"<html><head/><body><p>指定是否进行堆栈分析。该选项会大幅降低 Massif 的速度，"
"因此默认是关闭的。注意 Massif 假设启动时主堆栈大小为零。这并不准确，然而要精"
"确地计算是很困难的。此外，以零作为起始能够更好地显示主堆栈中用户程序能够实际"
"控制的部分的大小。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:174
#, kde-format
msgid "Profile stack (slows profiling down greatly)"
msgstr "分析堆栈（大幅减缓分析速度）"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:181
#, kde-format
msgid ""
"<html><head/><body><p>Tells Massif to profile memory at the page level "
"rather than at the malloc'd block level.</p></body></html>"
msgstr ""
"<html><head/><body><p>让 Massif 在页面级别进行内存分析，而不是在 malloc 的块"
"级别。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:184
#, kde-format
msgid "Pages as heap"
msgstr "页面作为堆"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/massif/massif_configpage.ui:191
#, kde-format
msgid ""
"<html><head/><body><p>&quot;Pages as heap&quot; cannot be used together with "
"&quot;Profile stack&quot;.</p></body></html>"
msgstr ""
"<html><head/><body><p>&quot;页面作为堆&quot; 不能和 &quot;分析堆栈&quot; 同时"
"启用。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchVisualizer)
#: tools/massif/massif_configpage.ui:214
#, kde-format
msgid "Launch Massif Visualizer after analysis finish"
msgstr "分析完成后启动 Massif 可视化程序"

#: tools/massif/massif_model.cpp:126
#, kde-format
msgid "Snapshot"
msgstr "快照"

#: tools/massif/massif_model.cpp:129
#, kde-format
msgid "Time"
msgstr "时间"

#: tools/massif/massif_model.cpp:132
#, kde-format
msgid "Heap"
msgstr "堆"

#: tools/massif/massif_model.cpp:135
#, kde-format
msgid "Heap (extra)"
msgstr "堆 (额外)"

#: tools/massif/massif_model.cpp:138
#, kde-format
msgid "Stack"
msgstr "堆叠"

#: tools/massif/massif_tool.cpp:35
#, kde-format
msgid "Massif"
msgstr "Massif"

#: tools/massif/massif_tool.cpp:36
#, kde-format
msgid "Massif (Heap Profiler)"
msgstr "Massif（堆分析器）"

#. i18n: ectx: property (text), widget (QLabel, snapshotsLabel)
#: tools/massif/massif_view.ui:36
#, kde-format
msgid "Snapshots"
msgstr "快照"

#. i18n: ectx: property (text), widget (QLabel, treesLabel)
#: tools/massif/massif_view.ui:56
#, kde-format
msgid "Heap trees"
msgstr "堆树"

#. i18n: ectx: property (text), widget (QPushButton, launchVisualizerButton)
#: tools/massif/massif_view.ui:70
#, kde-format
msgid "Launch visualizer"
msgstr "启动可视化程序"

#: tools/memcheck/memcheck_configpage.cpp:43
#, kde-format
msgid "definite"
msgstr "确定"

#: tools/memcheck/memcheck_configpage.cpp:44
#, kde-format
msgid "possible"
msgstr "可能"

#: tools/memcheck/memcheck_configpage.cpp:45
#, kde-format
msgid "indirect"
msgstr "间接"

#: tools/memcheck/memcheck_configpage.cpp:46
#, kde-format
msgid "reachable"
msgstr "可达"

#. i18n text ?
#: tools/memcheck/memcheck_configpage.cpp:50
#, kde-format
msgid "stdstring"
msgstr "stdstring"

#: tools/memcheck/memcheck_configpage.cpp:51
#, kde-format
msgid "length64"
msgstr "length64"

#: tools/memcheck/memcheck_configpage.cpp:52
#, kde-format
msgid "newarray"
msgstr "新数组"

#: tools/memcheck/memcheck_configpage.cpp:53
#, kde-format
msgid "multipleinheritance"
msgstr "多重继承"

#: tools/memcheck/memcheck_configpage.cpp:56
#, kde-format
msgid "high"
msgstr "高"

#: tools/memcheck/memcheck_configpage.cpp:57
#, kde-format
msgid "medium"
msgstr "中"

#: tools/memcheck/memcheck_configpage.cpp:58
#, kde-format
msgid "low"
msgstr "低"

#: tools/memcheck/memcheck_configpage.cpp:60
#, kde-format
msgid "alloc"
msgstr "分配"

#: tools/memcheck/memcheck_configpage.cpp:61
#, kde-format
msgid "free"
msgstr "释放"

#: tools/memcheck/memcheck_configpage.cpp:62
#, kde-format
msgid "alloc-and-free"
msgstr "分配和释放"

#: tools/memcheck/memcheck_configpage.cpp:63
#, kde-format
msgid "alloc-then-free"
msgstr "分配后释放"

#. i18n: ectx: property (text), widget (QLabel, leakResolutionLabel)
#: tools/memcheck/memcheck_configpage.ui:25
#, kde-format
msgid "Leak resolution:"
msgstr "泄漏检测分辨率："

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_leakResolution)
#: tools/memcheck/memcheck_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>When doing leak checking, determines how willing "
"Memcheck is to consider different backtraces to be the same for the purposes "
"of merging multiple leaks into a single leak report. When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">low</"
"span>, only the first two entries need match. When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">med</span>, four "
"entries have to match. When <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">high</span>, all entries need to match.</"
"p><p>For hardcore leak debugging, you probably want to use <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> together with <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--num-callers=40</span> or some such "
"large number.</p><p>Note that the <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--leak-resolution</span> setting does "
"not affect Memcheck's ability to find leaks. It only changes how the results "
"are presented.</p></body></html>"
msgstr ""
"<html><head/><body><p>在进行泄漏检查时，该选项决定了在将多个泄漏合并为一个泄"
"漏报告时，Memcheck 有多倾向于将不同的调用堆栈视为相同的。如果设置为 <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">low</"
"span>，那么只需要前两项匹配即可。如果设置为 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">med</span>，那么需"
"要有四个项目匹配。如果设置为<span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">high</span>，那所有项目都需要匹配。</p><p>如"
"果要进行硬核泄漏调试，您可能会想同时使用 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> 和 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--num-callers=40</span> 或者其他较大的数目。"
"</p><p>注意 <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--leak-resolution</span> 设置不影响 Memcheck 寻找泄漏的能力。"
"它只影响结果的展示方法。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, showLeakKindsLabel)
#: tools/memcheck/memcheck_configpage.ui:39
#, kde-format
msgid "Show leak kinds:"
msgstr "显示泄漏类型："

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_showLeakKinds)
#: tools/memcheck/memcheck_configpage.ui:46
#, kde-format
msgid "Specifies the leak kinds to show."
msgstr "指定要显示的泄漏类型。"

#. i18n: ectx: property (text), widget (QLabel, leakCheckHeuristicsLabel)
#: tools/memcheck/memcheck_configpage.ui:59
#, kde-format
msgid "Used heuristics:"
msgstr "要使用的策略："

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_leakCheckHeuristics)
#: tools/memcheck/memcheck_configpage.ui:66
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the set of leak check heuristics to be used "
"during leak searches. The heuristics control which interior pointers to a "
"block cause it to be considered as reachable.</p></body></html>"
msgstr ""
"<html><head/><body><p>指定要用于泄漏搜索过程的泄漏检查策略集。这些策略控制了"
"哪些指向一个块的内部指针会导致这个块被视为可达。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, keepStacktracesLabel)
#: tools/memcheck/memcheck_configpage.ui:76
#, kde-format
msgid "Stacktraces keeping:"
msgstr "保留的堆栈跟踪："

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_keepStacktraces)
#: tools/memcheck/memcheck_configpage.ui:83
#, kde-format
msgid ""
"<html><head/><body><p>Controls which stack trace(s) to keep for malloc'd and/"
"or free'd blocks. </p><p>With <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, a stack trace is "
"recorded at allocation time, and is associated with the block. When the "
"block is freed, a second stack trace is recorded, and this replaces the "
"allocation stack trace. As a result, any &quot;use after free&quot; errors "
"relating to this block can only show a stack trace for where the block was "
"freed. </p><p>With <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">alloc-and-free</span>, both allocation and the "
"deallocation stack traces for the block are stored. Hence a &quot;use after "
"free&quot; error will show both, which may make the error easier to "
"diagnose. Compared to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, this setting "
"slightly increases Valgrind's memory use as the block contains two "
"references instead of one. </p><p>With <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc</span>, only "
"the allocation stack trace is recorded (and reported). With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, "
"only the deallocation stack trace is recorded (and reported). These values "
"somewhat decrease Valgrind's memory and cpu usage. They can be useful "
"depending on the error types you are searching for and the level of detail "
"you need to analyze them. For example, if you are only interested in memory "
"leak errors, it is sufficient to record the allocation stack traces. </"
"p><p>With <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">none</span>, no stack traces are recorded for malloc and "
"free operations. If your program allocates a lot of blocks and/or allocates/"
"frees from many different stack traces, this can significantly decrease cpu "
"and/or memory required. Of course, few details will be reported for errors "
"related to heap blocks. </p><p>Note that once a stack trace is recorded, "
"Valgrind keeps the stack trace in memory even if it is not referenced by any "
"block. Some programs (for example, recursive algorithms) can generate a huge "
"number of stack traces. If Valgrind uses too much memory in such "
"circumstances, you can reduce the memory required with the options <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"keep-stacktraces</span> and/or by using a smaller value for the option <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"num-callers</span>. </p></body></html>"
msgstr ""
"<html><head/><body><p>控制对被 malloc / free 的块要保留哪些堆栈跟踪。</p><p>"
"如果选择 <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">alloc-then-free</span>，那么分配时会记录一个堆栈跟踪，并且关联到分"
"配的块上。当此块被释放时，会记录第二个堆栈跟踪，并且这会替代掉分配时记录的堆"
"栈跟踪。这么做的结果是，所有关于此块的 &quot;释放后使用&quot; 错误只会显示一"
"个该块被释放时的堆栈跟踪。</p><p>如果选择 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc-and-free</"
"span>，那么一个块分配时和释放时的堆栈跟踪都会被保留。因此，对 &quot;释放后使"
"用&quot; 的错误，这两个都会被显示出来，这样可能会使得对问题的诊断变容易。比"
"起 <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">alloc-then-free</span>，此设置会稍微增加 Valgrind 的内存使用，因为"
"每个块会有两条记录，而不是一条。</p><p>如果设置为 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc</span>，那么"
"只有分配时的堆栈跟踪会被记录（及报告）。如果选择 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>，那么只"
"有释放时的堆栈跟踪会被记录（及报告）。这两个值会略微减少 Valgrind 的内存和 "
"CPU 使用。根据您在寻找的错误类型以及您分析它们需要的资料详细程度，它们或许有"
"用。例如，如果您只关心内存泄漏错误，记录分配时的堆栈跟踪就足够了。</p><p>如果"
"选择 <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">none</span>，那么对 malloc 和 free 操作不会记录堆栈跟踪。如果您的程"
"序分配大量的块，或者在许多不同的调用堆栈下分配或释放内存，那么这可以大幅减少 "
"CPU 及 内存使用。当然，如果有和堆块相关的问题，在这种设置下不会报告细节。</"
"p><p>注意，一旦堆栈跟踪被记录了，那么 Valgrind 会一直把它保存在内存中，即使没"
"有任何块引用它。某些程序（例如，递归算法）可能会产生大量的调用堆栈。如果 "
"Valgrind 在这种情况下使用了过多内存，您可以通过设置选项 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--keep-"
"stacktraces</span> 来减少内存使用，或者将选项 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--num-callers</"
"span>设置为一个更小的值。</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, freelistVolLabel)
#: tools/memcheck/memcheck_configpage.ui:90
#, kde-format
msgid "Freelist maximum size:"
msgstr "已释放列表最大大小："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistVol)
#: tools/memcheck/memcheck_configpage.ui:100
#, kde-format
msgid ""
"<html><head/><body><p>When the client program releases memory using <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span> (in <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">C</span>) or <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete</span> (<span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">C++</span>), that "
"memory is not immediately made available for re-allocation. Instead, it is "
"marked inaccessible and placed in a queue of freed blocks. The purpose is to "
"defer as long as possible the point at which freed-up memory comes back into "
"circulation. This increases the chance that Memcheck will be able to detect "
"invalid accesses to blocks for some significant period of time after they "
"have been freed.</p><p>This option specifies the maximum total size, in "
"bytes, of the blocks in the queue. The default value is twenty million "
"bytes. Increasing this increases the total amount of memory used by Memcheck "
"but may detect invalid uses of freed blocks which would otherwise go "
"undetected.</p></body></html>"
msgstr ""
"<html><head/><body><p>当客户端程序使用<span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>（<span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">C 语"
"言</span>）或者<span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">delete</span>（<span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">C++</span>）释放内存时，此内存并不能立刻用于"
"重新分配。相反，它会被标记为不可用，并被添加到已释放内存块的队列中。这么做的"
"目的是为了尽可能延缓被释放的内存重新回流的时间。这大幅增加了 Memcheck 在内存"
"块被释放很久之后检测到对它们的非法访问的机会。</p><p>该选项指定了在该队列中内"
"存块的最大总大小。默认值为两千万字节。增加这个值会增加 Memcheck 使用的总内存"
"量，但是也会能够检测到那些一般无法检测到的对已被释放内存块的错误使用。</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QLabel, freelistBigBlocksLabel)
#: tools/memcheck/memcheck_configpage.ui:107
#, kde-format
msgid "Freelist big-blocks:"
msgstr "已释放列表大块阈值："

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistBigBlocks)
#: tools/memcheck/memcheck_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>When making blocks from the queue of freed blocks "
"available for re-allocation, Memcheck will in priority re-circulate the "
"blocks with a size greater or equal to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--freelist-big-"
"blocks</span>. This ensures that freeing big blocks (in particular freeing "
"blocks bigger than <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">--freelist-vol</span>) does not immediately lead to a "
"re-circulation of all (or a lot of) the small blocks in the free list. In "
"other words, this option increases the likelihood to discover dangling "
"pointers for the &quot;small&quot; blocks, even when big blocks are freed.</"
"p><p>Setting a value of 0 means that all the blocks are re-circulated in a "
"FIFO order.</p></body></html>"
msgstr ""
"<html><head/><body><p>当从已被释放的块队列中取出块来用于重新分配时，Memcheck "
"会优先重用那些大小大于等于 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--freelist-big-blocks</span> 的块。这保证了"
"释放掉一个大的块（特别是那些大于 <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--freelist-vol</span> 的块）不会立刻导"
"致所有（或者大量）已释放列表中的小块被重用。换句话说，这个选项提高了发现指向 "
"&quot;小&quot; 块的悬空指针的可能性，即使在有大块被释放的情况下。</p><p>将此"
"值设置为 0 意味着所有块会按照 FIFO（先进先出）的次序被重用。</p></body></"
"html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:150
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck reports uses of undefined "
"value errors. Set this to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">no</span> if you don't want to see "
"undefined value errors. It also has the side effect of speeding up Memcheck "
"somewhat.</p></body></html>"
msgstr ""
"<html><head/><body><p>控制 Memcheck 是否要报告未定义值错误。如果您不想看见未"
"定义值错误，将此设置为 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">no</span>。这同时也有稍微加快 Memcheck 运行"
"速度的副作用。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:153
#, kde-format
msgid "Show undefined values usage"
msgstr "显示对未定义值的使用"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:163
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Memcheck checks that heap blocks are "
"deallocated using a function that matches the allocating function. That is, "
"it expects <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">free</span> to be used to deallocate blocks allocated by "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">malloc</span>, <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">delete</span> for blocks allocated by <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>, "
"and <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">delete[]</span> for blocks allocated by <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span>. If a "
"mismatch is detected, an error is reported. This is in general important "
"because in some environments, freeing with a non-matching function can cause "
"crashes.</p><p>There is however a scenario where such mismatches cannot be "
"avoided. That is when the user provides implementations of <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">new[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">malloc</span> and of <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">free</span>, and these functions are "
"asymmetrically inlined. For example, imagine that <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span> is "
"inlined but <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">new[]</span> is not. The result is that Memcheck &quot;"
"sees&quot; all <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">delete[]</span> calls as direct calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, even "
"when the program source contains no mismatched calls.</p><p>This causes a "
"lot of confusing and irrelevant error reports. <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--show-mismatched-"
"frees=no</span> disables these checks. It is not generally advisable to "
"disable them, though, because you may miss real errors as a result.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>若启用，则 Memcheck 会检查堆块是否被用和分配时用的函数"
"对应的函数释放。也就是说，它会检查 <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">free</span> 被用来释放用 <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">malloc</"
"span> 分配的块，以及 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">delete</span> 被用来释放用 <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span> 分"
"配的块，以及 <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">delete[]</span> 被用来释放用 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span> 分配的"
"块。如果它检测到不匹配的情况，它会报告一个错误。一般来说这比较重要，因为在某"
"些环境下，用不匹配的函数释放会导致崩溃。</p><p>然而，某些情况下这种不匹配不可"
"避免。例如，当用户自己提供了 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">new</span>/<span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span> 的实"
"现，并且它们调用了 <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">malloc</span>，或者提供了 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> 的实现，并且它们调用了 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>，并且这"
"些函数被不对称地内联了的话。例如，想象一下如果 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span> 被"
"内联了，但是 <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">new[]</span> 没有。这种情况下，Memcheck 会将所有的 <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> 调用 &quot;视作&quot; 对 <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span> 的直接"
"调用，即使程序源代码中并没有不匹配的调用。</p><p>这会令人非常疑惑，并且会产生"
"很多无关的错误报告。<span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">--show-mismatched-frees=no</span> 会禁止这些检查。但是，"
"一般来说不推荐禁止它们，因为您可能会错过真实存在的错误。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:166
#, kde-format
msgid "Show mismatched frees"
msgstr "显示不匹配的释放"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:173
#, kde-format
msgid ""
"<html><head/><body><p>Controls how Memcheck handles 32-, 64-, 128- and 256-"
"bit naturally aligned loads from addresses for which some bytes are "
"addressable and others are not. When <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">yes</span>, such loads do not produce "
"an address error. Instead, loaded bytes originating from illegal addresses "
"are marked as uninitialised, and those corresponding to legal addresses are "
"handled in the normal way.</p><p>When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">no</span>, loads "
"from partially invalid addresses are treated the same as loads from "
"completely invalid addresses: an illegal-address error is issued, and the "
"resulting bytes are marked as initialised.</p><p>Note that code that behaves "
"in this way is in violation of the ISO C/C++ standards, and should be "
"considered broken. If at all possible, such code should be fixed.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>控制 Memcheck 在处理 32-, 64-, 128- 和 256-位自然对齐的"
"读取时，如果有些字节可寻址而有些不行的情况下的行为。如果设置为 <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">yes</"
"span>，那么这些读取不会触发一个地址错误。相反，从非法地址读取的字节会被标记为"
"未初始化的，而那些从合法地址读取的会被正常处理。</p><p>如果设置为<span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">no</span>，"
"那么从部分非法地址的读取会被当作完全非法地址的读取：这会触发一个非法地址错"
"误，同时读取的字节会被标记为已初始化的。</p><p>注意，有这种行为的代码违反了 "
"ISO C/C++ 标准，应被视为有问题的代码。如果可能的话，这些代码应该被修正。</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:176
#, kde-format
msgid "Allow partial loads"
msgstr "允许部分载入"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:183
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck tracks the origin of "
"uninitialised values. By default, it does not, which means that although it "
"can tell you that an uninitialised value is being used in a dangerous way, "
"it cannot tell you where the uninitialised value came from. This often makes "
"it difficult to track down the root problem.</p><p>When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">yes</"
"span>, Memcheck keeps track of the origins of all uninitialised values. "
"Then, when an uninitialised value error is reported, Memcheck will try to "
"show the origin of the value. An origin can be one of the following four "
"places: a heap block, a stack allocation, a client request, or miscellaneous "
"other sources (eg, a call to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">brk</span>).</p><p>For uninitialised values "
"originating from a heap block, Memcheck shows where the block was allocated. "
"For uninitialised values originating from a stack allocation, Memcheck can "
"tell you which function allocated the value, but no more than that -- "
"typically it shows you the source location of the opening brace of the "
"function. So you should carefully check that all of the function's local "
"variables are initialised properly. </p><p>Performance overhead: origin "
"tracking is expensive. It halves Memcheck's speed and increases memory use "
"by a minimum of 100MB, and possibly more. Nevertheless it can drastically "
"reduce the effort required to identify the root cause of uninitialised value "
"errors, and so is often a programmer productivity win, despite running more "
"slowly. </p><p>Accuracy: Memcheck tracks origins quite accurately. To avoid "
"very large space and time overheads, some approximations are made. It is "
"possible, although unlikely, that Memcheck will report an incorrect origin, "
"or not be able to identify any origin. </p><p>Note that the combination "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--track-origins=yes</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--undef-value-errors=no</span> is "
"nonsensical. Memcheck checks for and rejects this combination at startup.</"
"p></body></html>"
msgstr ""
"<html><head/><body><p>控制 Memcheck 是否应追踪未初始化值的来源。默认情况下不"
"追踪，也就是说虽然它能告诉你有未初始化值以危险的方式被使用了，它无法告诉你这"
"个未初始化值的来源。这常常使得追寻根本问题的过程变得困难。</p><p>如果设置为"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">yes</span>，那么 Memcheck 会跟踪所有未初始化值的来源。这样，如果有个未初始"
"化值错误被报告了，那么 Memcheck 会尝试显示这个值的来源。它可能来自以下四个地"
"方之一：一个堆块，一个栈上的分配，一个客户请求，或者其它来源（例如，一个对 "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">brk</span> 的调用）。</p><p>对来自堆块的未初始化值，Memcheck 会显示那个块"
"的位置。对来自栈分配的未初始化值，Memcheck 会告诉你哪个函数分配了那个值，但仅"
"止于此 —— 一般来说它会显示该函数的起始括号的源代码位置。这种情况下，您需要仔"
"细检查该函数的所有本地变量是否都被正确初始化了。</p><p>性能开销：来源追踪比较"
"昂贵。它会使得 Memcheck 的速度减半，并且至少增加 100MB 的内存使用量，可能更"
"多。尽管如此，它可以大幅减少寻找未定义变量错误源头的努力，从而提升程序员的工"
"作效率，即使它跑得更慢。</p><p>精度：Memcheck 能相当精确地追踪来源。要避免过"
"大的空间和时间开销，我们进行了一些近似。Memcheck 依旧有可能报告一个错误的来"
"源，或者无法找到任何来源，虽然这比较少见。</p><p>注意同时指定 <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--track-"
"origins=yes</span> 和 <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--undef-value-errors=no</span> 并没有意义。"
"Memcheck 在启动时会检查并拒绝这种组合。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:186
#, kde-format
msgid "Track origins of all uninitialised values"
msgstr "追踪所有未初始化值的来源"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:193
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck should employ more precise "
"but also more expensive (time consuming) algorithms when checking the "
"definedness of a value. The default setting is not to do that and it is "
"usually sufficient. However, for highly optimised code valgrind may "
"sometimes incorrectly complain. Invoking valgrind with <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--expensive-"
"definedness-checks=yes</span> helps but comes at a performance cost. Runtime "
"degradation of 25% have been observed but the extra cost depends a lot on "
"the application at hand.</p></body></html>"
msgstr ""
"<html><head/><body><p>指定 Memcheck 在检测一个变量是否有定义时要不要使用更精"
"确但也更昂贵（更花时间）的算法。默认设置是不用，一般就已经能满足需求了。但"
"是，对于被高度优化过的代码，valgrind 有时会错误地报错。如果在执行 valgrind 时"
"使用 <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">--expensive-definedness-checks=yes</span> 参数会有所帮助，但是这会"
"带来性能上的开销。有观察到过 25% 的运行时性能损失，但是这些额外开销非常依赖于"
"具体的应用程序。</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:196
#, kde-format
msgid "Expensive definedness checks"
msgstr "较昂贵的定义检查"

#: tools/memcheck/memcheck_tool.cpp:35
#, kde-format
msgid "Memcheck"
msgstr "Memcheck"

#: tools/memcheck/memcheck_tool.cpp:36
#, kde-format
msgid "Memcheck (Memory Error Detector)"
msgstr "Memcheck (内存错误检测器)"

#: toolviewfactory.cpp:47
#, kde-format
msgid "Valgrind Output"
msgstr "Valgrind 输出"

#: toolviewfactory.cpp:49
#, kde-format
msgid ""
"<b>Valgrind</b><p>Shows the output of valgrind. Valgrind detects:<br/>use of "
"uninitialized memory;<br/>reading/writing memory after it has been free'd;"
"<br/>reading/writing off the end of malloc'd blocks;<br/>reading/writing "
"inappropriate areas on the stack;<br/>memory leaks &mdash; where pointers to "
"malloc'd blocks are lost forever;<br/>passing of uninitialised and/or "
"unaddressable memory to system calls;<br/>mismatched use of malloc/new/new "
"[] vs free/delete/delete [];<br/>some abuses of the POSIX pthread API.</p>"
msgstr ""
"<b>Valgrind</b><p>显示 Valgrind 的输出。Valgrind 能检测<br/>使用未初始化的内"
"存<br/>在内存释放后进行读/写<br/>读写超越 malloc 分配的内存块<br/>读写堆栈中"
"不适当的区域<br/>内存泄露 &mdash; malloc 分配的指针永远丢失的问题<br/>传递未"
"初始化和/或不可访问的内存给系统调用<br/>对 malloc/new/new [] 和 free/delete/"
"delete [] 的使用不配对<br/>一些对 POSIX pthread API 的不当使用。</p>"
