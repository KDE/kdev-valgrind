# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR This file is copyright:
# This file is distributed under the same license as the kdev-valgrind package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: kdev-valgrind\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2025-11-17 09:00+0000\n"
"PO-Revision-Date: 2026-01-29 05:49+0100\n"
"Last-Translator: Temuri Doghonadze <temuri.doghonadze@gmail.com>\n"
"Language-Team: Georgian <kde-i18n-doc@kde.org>\n"
"Language: ka\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.8\n"

#: config/globalconfigpage.cpp:45 launchmode.cpp:47 plugin.cpp:60
#: problemmodel.cpp:54 problemmodel.cpp:67
#, kde-format
msgid "Valgrind"
msgstr "Valgrind"

#: config/globalconfigpage.cpp:50
#, kde-format
msgid "Configure Valgrind Settings"
msgstr "Valgrind-ის მორგება"

#. i18n: ectx: property (title), widget (QGroupBox, pathsGroupBox)
#: config/globalconfigpage.ui:29
#, kde-format
msgid "Valgrind executables"
msgstr "Valgrind -ის გამშვები ფაილები"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:35
#, kde-format
msgid "Valgrind:"
msgstr "Valgrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:55
#, kde-format
msgid "callgrind_annotate:"
msgstr "callgrind_annotate:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:75
#, kde-format
msgid "cg_annotate:"
msgstr "cg_annotate:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox)
#: config/globalconfigpage.ui:98
#, kde-format
msgid "Visualizers executables"
msgstr "ვიზუალიზერის გამშვები ფაილები"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:104
#, kde-format
msgid "KCachegrind:"
msgstr "KCachegrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:124
#, kde-format
msgid "Massif Visualizer:"
msgstr "ვიზუალიზერი Massif:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox_2)
#: config/globalconfigpage.ui:147
#, kde-format
msgid "Output"
msgstr "გამოტანა"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:153
#, kde-format
msgid ""
"<html><head/><body><p>Valgrind messages will be displayed in the output view "
"during analysis.</p><p>Useful for plugin debugging.</p></body></html>"
msgstr ""
"<html><head/><body><p>ანალიზის დროს Valgrind-ის შეტყობინებები გამოტანის "
"ხედში იქნება ნაჩვენები .</p><p>სასარგებლოა დამატების გასამართად.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:156
#, kde-format
msgid "Show valgrind output during analysis"
msgstr "ანალიზის დროს valgrind -ის გამოტანის ჩვენება"

#: core/job.cpp:109
#, kde-format
msgid "%1 Analysis (%2)"
msgstr "%1 -ის ანალიზი (%2)"

#: core/job.cpp:112
#, kde-format
msgctxt ""
"%1 - the name of a Valgrind tool, %2 - the name of the target of a Valgrind "
"analysis"
msgid "%1 (%2)"
msgstr "%1 (%2)"

#: core/job.cpp:236
#, kde-format
msgid "Failed to start valgrind from \"%1\"."
msgstr "\"%1\"-დან valgrind -ის გაშვების შეცდომა."

#: core/job.cpp:243
#, kde-format
msgid "Valgrind crashed."
msgstr "Valgrind -ი ავარიულად დასრულდა."

#: core/job.cpp:248
#, kde-format
msgid "Valgrind process timed out."
msgstr "Valgrind-ის პროცესის მოლოდინის ვადა გავიდა."

#: core/job.cpp:252
#, kde-format
msgid "Write to Valgrind process failed."
msgstr "Valgrind-ის პროცესში ჩაწერის შეცდომა."

#: core/job.cpp:256
#, kde-format
msgid "Read from Valgrind process failed."
msgstr "Valgrind-ის პროცესიდან წაკითხვის შეცდომა."

#: core/job.cpp:274 core/job.cpp:320
#, kde-format
msgid "Please review your Valgrind launch configuration."
msgstr "გადახედეთ Valgrind-ის გაშვების თქვენს კონფიგურაციას."

#: core/job.cpp:276
#, kde-format
msgid "Unknown Valgrind process error."
msgstr "Valgrind-ის პროცესის უცნობი შცდომა."

#: core/job.cpp:282 core/job.cpp:322 core/private/xmlparser.cpp:262
#: core/utils.cpp:124
#, kde-format
msgid "Valgrind Error"
msgstr "Valgrind -ის შეცდომა"

#: core/job.cpp:298
#, kde-format
msgid "Executing command: "
msgstr "ბრძანების შესრულება: "

#: core/job.cpp:316
#, kde-format
msgid "Failed to execute the command:"
msgstr "ბრძანების გაშვების შეცდომა:"

#: core/private/common_configpage.cpp:30
#, kde-format
msgid "Valgrind Common Settings"
msgstr "Valgrind-ის საერთო პარამეტრები"

#. i18n: ectx: property (text), widget (QLabel, numCallersLabel)
#: core/private/common_configpage.ui:22
#, kde-format
msgid "Display stac&k to depth:"
msgstr "სტე&კის ჩვენება სიღრმემდე:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_numCallers)
#: core/private/common_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the maximum number of entries shown in stack "
"traces that identify program locations. Note that errors are commoned up "
"using only the top four function locations (the place in the current "
"function, and that of its three immediate callers). So this doesn't affect "
"the total number of errors reported.</p><p>The maximum value for this is "
"500. Note that higher settings will make Valgrind run a bit more slowly and "
"take a bit more memory, but can be useful when working with programs with "
"deeply-nested call chains.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს სტეკის კვალში საჩვენებელი ჩანაწერების "
"მაქსიმალურ რაოდენობას, რომლებიც პროგრამის მდებარეობებს აიდენტიფიცირებს. "
"გაითვალისწინეთ, რომ შეცდომები ჯგუფდება მხოლოდ ზედა ოთხი ფუნქციის მდებარეობით "
"(მიმდინარე ფუნქციის ადგილი და მისი სამი უშუალო გამომძახებელი). ასე რომ, ეს "
"არ ახდენს გავლენას მოხსენებული შეცდომების საერთო რაოდენობაზე.</p><p>ამ "
"პარამეტრის მაქსიმალური მნიშვნელობაა 500. გაითვალისწინეთ, რომ მაღალი "
"მნიშვნელობები Valgrind-ს ოდნავ შეანელებს და მეტ მეხსიერებას წაართმევს, "
"მაგრამ შეიძლება სასარგებლო იყოს ღრმად ჩადგმული გამოძახებების ჯაჭვების მქონე "
"პროგრამებთან მუშაობისას.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, maxStackframeLabel)
#: core/private/common_configpage.ui:39
#, kde-format
msgid " Maximum size of a stack frame:"
msgstr " სტეკის კადრის მაქს. ზომა:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maxStackframe)
#: core/private/common_configpage.ui:49
#, kde-format
msgid ""
"<html><head/><body><p>The maximum size of a stack frame. If the stack "
"pointer moves by more than this amount then Valgrind will assume that the "
"program is switching to a different stack.</p><p>You may need to use this "
"option if your program has large stack-allocated arrays. Valgrind keeps "
"track of your program's stack pointer. If it changes by more than the "
"threshold amount, Valgrind assumes your program is switching to a different "
"stack, and Memcheck behaves differently than it would for a stack pointer "
"change smaller than the threshold. Usually this heuristic works well. "
"However, if your program allocates large structures on the stack, this "
"heuristic will be fooled, and Memcheck will subsequently report large "
"numbers of invalid stack accesses. This option allows you to change the "
"threshold to a different value.</p><p>You should only consider use of this "
"option if Valgrind's debug output directs you to do so. In that case it will "
"tell you the new threshold you should specify.</p><p>In general, allocating "
"large structures on the stack is a bad idea, because you can easily run out "
"of stack space, especially on systems with limited memory or which expect to "
"support large numbers of threads each with a small stack, and also because "
"the error checking performed by Memcheck is more effective for heap-"
"allocated data than for stack-allocated data. If you have to use this "
"option, you may wish to consider rewriting your code to allocate on the heap "
"rather than on the stack.</p></body></html>"
msgstr ""
"<html><head/><body><p>სტეკის ჩარჩოს მაქსიმალური ზომა. თუ სტეკის მაჩვენებელი "
"ამ რაოდენობაზე მეტით გადაადგილდება, Valgrind ჩათვლის, რომ პროგრამა სხვა "
"სტეკზე გადადის.</p><p>შესაძლოა დაგჭირდეთ ამ პარამეტრის გამოყენება, თუ თქვენს "
"პროგრამას აქვს სტეკზე გამოყოფილი დიდი მასივები. Valgrind თვალყურს ადევნებს "
"თქვენი პროგრამის სტეკის მაჩვენებელს. თუ ის ზღვრულ მნიშვნელობაზე მეტით "
"იცვლება, Valgrind ვარაუდობს, რომ თქვენი პროგრამა სხვა სტეკზე გადადის და "
"Memcheck განსხვავებულად იქცევა, ვიდრე ზღვარზე მცირე ცვლილების შემთხვევაში. "
"როგორც წესი, ეს ევრისტიკა კარგად მუშაობს. თუმცა, თუ თქვენი პროგრამა სტეკზე "
"დიდ სტრუქტურებს გამოყოფს, ეს ევრისტიკა შეცდება და Memcheck შემდგომში დიდი "
"რაოდენობით სტეკზე არავალიდური წვდომის შემთხვევებს დააფიქსირებს. ეს პარამეტრი "
"საშუალებას გაძლევთ, შეცვალოთ ზღვარი სხვა მნიშვნელობით.</p><p>ამ პარამეტრის "
"გამოყენება მხოლოდ იმ შემთხვევაში უნდა განიხილოთ, თუ Valgrind-ის გამართვის "
"გამონატანი ამისკენ მიგითითებთ. ასეთ შემთხვევაში, ის თავად გეტყვით ახალ "
"ზღვარს, რომელიც უნდა მიუთითოთ.</p><p>ზოგადად, სტეკზე დიდი სტრუქტურების "
"გამოყოფა ცუდი აზრია, რადგან შეიძლება ადვილად ამოგეწუროთ სტეკის სივრცე, "
"განსაკუთრებით შეზღუდული მეხსიერების მქონე სისტემებზე ან იქ, სადაც "
"მოსალოდნელია დიდი რაოდენობით ნაკადების მხარდაჭერა მცირე სტეკებით; ასევე "
"იმიტომ, რომ Memcheck-ის მიერ შესრულებული შეცდომების შემოწმება უფრო ეფექტურია "
"მეხსიერების გროვაზე გამოყოფილი მონაცემებისთვის, ვიდრე სტეკზე "
"გამოყოფილისთვის. თუ ამ პარამეტრის გამოყენება მაინც გიწევთ, სასურველია "
"განიხილოთ კოდის გადაწერა, რათა მონაცემები სტეკის ნაცვლად მეხსიერების გროვაზე "
"გამოყოთ.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: core/private/common_configpage.ui:56
#, kde-format
msgid "&Extra parameters:"
msgstr "&დამატებითი პარამეტრები:"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:82
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Valgrind stops reporting errors after "
"10,000,000 in total, or 1,000 different ones, have been seen. This is to "
"stop the error tracking machinery from becoming a huge performance overhead "
"in programs with many errors.</p></body></html>"
msgstr ""
"<html><head/><body><p>როდესაც ჩართულია, Valgrind წყვეტს შეცდომების შესახებ "
"შეტყობინებას მას შემდეგ, რაც ჯამში 10,000,000, ან 1,000 განსხვავებული "
"შეცდომა დაფიქსირდება. ეს კეთდება იმისთვის, რომ შეცდომების თვალყურის დევნების "
"მექანიზმი არ გახდეს მეტისმეტად დიდი წარმადობის დანახარჯი ბევრი შეცდომის "
"მქონე პროგრამებში.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:85
#, kde-format
msgid "Limit errors if too many"
msgstr "შეცდომების შეზღუდვა, თუ რაოდენობა მეტისმეტად დიდია"

#: core/private/xmlparser.cpp:258
#, kde-format
msgid "Valgrind XML Parsing: error at line %1, column %2: %3"
msgstr "Valgrind-ის XML-ის დამუშავება: შეცდომა ხაზზე %1, სვეტი %2: %3"

#: core/utils.cpp:47
#, kde-format
msgid "Instruction Fetch"
msgstr "ინსტრუქციის გამოთხოვა"

#: core/utils.cpp:48
#, kde-format
msgid "Data Read Access"
msgstr "მონაცემების კითხვის წვდომა"

#: core/utils.cpp:49
#, kde-format
msgid "Data Write Access"
msgstr "მონაცემების ჩაწერის წვდომა"

#: core/utils.cpp:50
#, kde-format
msgid "L1 Instr. Fetch Miss"
msgstr "L1 ინსტრ. გამოთხ. აცდ"

#: core/utils.cpp:51
#, kde-format
msgid "L1 Data Read Miss"
msgstr "L1 მონაც. წაკითხვ. აცდ"

#: core/utils.cpp:52
#, kde-format
msgid "L1 Data Write Miss"
msgstr "L1 მონაც. ჩაწერ. აცდ"

#: core/utils.cpp:53
#, kde-format
msgid "LL Instr. Fetch Miss"
msgstr "LL ინსტრ. გამოთხ. აცდ"

#: core/utils.cpp:54
#, kde-format
msgid "LL Data Read Miss"
msgstr "LL მონაც. წაკითხვ. აცდ"

#: core/utils.cpp:55
#, kde-format
msgid "LL Data Write Miss"
msgstr "LL მონაც. ჩაწერ. აცდ"

#: core/utils.cpp:57
#, kde-format
msgid "Conditional Branch"
msgstr "პირობითი ბრენჩი"

#: core/utils.cpp:58
#, kde-format
msgid "Mispredicted Cond. Branch"
msgstr "გამოუცნობი პირობ. ბრენჩი"

#: core/utils.cpp:59
#, kde-format
msgid "Indirect Branch"
msgstr "არაპირდაპირი ბრენჩი"

#: core/utils.cpp:60
#, kde-format
msgid "Mispredicted Ind. Branch"
msgstr "გამოუცნობი არაპ. ბრენჩი"

#: core/utils.cpp:116
#, kde-format
msgid "Failed to start visualizer from \"%1\"."
msgstr "ვიზუალიზატორის გაშვების შეცდომა \"%1\"-დან."

#: core/utils.cpp:118
#, kde-format
msgid "Check your settings and install the visualizer if necessary."
msgstr "შეამოწმეთ პარამეტრები და დააყენეთ ვიზუალიზატორიც, თუ საჭიროა."

#: core/utils.cpp:120
#, kde-format
msgid "Error during visualizer execution:"
msgstr "შეცდომა ვიზუალიზატორის შესრულებისას:"

#: core/widgets/menubutton.cpp:95 tools/memcheck/memcheck_configpage.cpp:64
#, kde-format
msgid "none"
msgstr "არცერთი"

#: core/widgets/menubutton.cpp:98
#, kde-format
msgid "all"
msgstr "ყველა"

#. i18n: ectx: Menu (valgrind)
#: kdevvalgrind.rc:6
#, kde-format
msgid "Run Valgrind Analysis"
msgstr "Valgrind-ის ანალიზის გაშვება"

#: plugin.cpp:80
#, kde-format
msgid "Run %1"
msgstr "%1-ის გაშვება"

#: problemmodel.cpp:68
#, kde-format
msgctxt "@info:tooltip"
msgid "Re-Run %1 Analysis for Current Launch Configuration"
msgstr "%1-ის ანალიზის თავიდან გაშვება მიმდინარე გაშვების კონფიგურაციისთვის"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of cache access and "
"miss counts.</p></body></html>"
msgstr ""
"<html><head/><body><p>ჩართავს, ან გამორთავს კეშის წვდომებისა და აცილებების "
"რაოდენობის დათვლას.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:26
#: tools/callgrind/callgrind_configpage.ui:26
#, kde-format
msgid "Cache simulation"
msgstr "კეშის სიმულაცია"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:36
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of branch instruction "
"and misprediction counts. By default this is disabled as it slows Cachegrind "
"down by approximately 25%. Note that you cannot specify <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--cache-sim=no</"
"span> and <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--branch-sim=no</span> together, as that would leave "
"Cachegrind with no information to collect.</p></body></html>"
msgstr ""
"<html><head/><body><p>რთავს ან თიშავს დატოტვის ინსტრუქციებისა და არასწორი "
"პროგნოზების რაოდენობის შეგროვებას. ნაგულისხმევად ეს გამორთულია, რადგან იგი "
"Cachegrind-ს დაახლოებით 25%-ით ანელებს. გაითვალისწინეთ, რომ თქვენ არ "
"შეგიძლიათ მიუთითოთ <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">--cache-sim=no</span> და <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--branch-sim=no</"
"span> ერთად, რადგან ამ შემთხვევაში Cachegrind-ს შესაგროვებელი ინფორმაცია "
"აღარ დარჩება.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:39
#: tools/callgrind/callgrind_configpage.ui:39
#, kde-format
msgid "Branch simulation"
msgstr "ბრენჩის სიმულაცია"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/cachegrind/cachegrind_configpage.ui:49
#, kde-format
msgid ""
"You cannot disable both cache and branch simulation, as that would leave "
"Cachegrind with no information to collect."
msgstr ""
"ორივეს, კეშს და შტოს სიმულაციას ვერ გამორთავთ, რადგან ეს Cachegrind-ს "
"მოსაგროვებელი ინფორმაციის გარეშე დატოვებს."

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:74
#: tools/callgrind/callgrind_configpage.ui:58 tools/drd/drd_configpage.ui:51
#: tools/helgrind/helgrind_configpage.ui:46
#, kde-format
msgid "Extra parameters:"
msgstr "დამატებითი პარამეტრები:"

#. i18n: ectx: property (text), widget (QLabel, cgAnnotateArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:91
#, kde-format
msgid "cg_annotate parameters:"
msgstr "cg_annotate-ის პარამეტრები:"

#: tools/cachegrind/cachegrind_model.cpp:155
#: tools/callgrind/callgrind_model.cpp:290
#, kde-format
msgid "Function"
msgstr "ფუნქცია"

#: tools/cachegrind/cachegrind_tool.cpp:35
#, kde-format
msgid "Cachegrind"
msgstr "Cachegrind"

#: tools/cachegrind/cachegrind_tool.cpp:36
#, kde-format
msgid "Cachegrind (Cache and Branch-Prediction Profiler)"
msgstr "Cachegrind (კეშისა და შტოს ამოცნობის პროფაილერი)"

#. i18n: ectx: property (placeholderText), widget (QLineEdit, searchEdit)
#: tools/cachegrind/cachegrind_view.ui:31 tools/callgrind/callgrind_view.ui:40
#, kde-format
msgid "Search..."
msgstr "ძებნა..."

#. i18n: ectx: property (text), widget (QCheckBox, percenageValues)
#: tools/cachegrind/cachegrind_view.ui:41 tools/callgrind/callgrind_view.ui:53
#, kde-format
msgid "Percentage values"
msgstr "პროცენტული მნიშვნელობები"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/callgrind/callgrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do full cache simulation. By "
"default, only instruction read accesses will be counted (&quot;Ir&quot;). "
"With cache simulation, further event counters are enabled: </p><p>Cache "
"misses on instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), </p><p>data "
"read accesses (&quot;Dr&quot;) and related cache misses (&quot;D1mr&quot;/"
"&quot;DLmr&quot;), </p><p>data write accesses (&quot;Dw&quot;) and related "
"cache misses (&quot;D1mw&quot;/&quot;DLmw&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>მიუთითეთ, გსურთ თუ არა ქეშის სრული სიმულაციის "
"ჩატარება. ნაგულისხმევად, მხოლოდ ინსტრუქციების წაკითხვის წვდომები დაითვლება "
"(&quot;Ir&quot;). ქეშის სიმულაციის შემთხვევაში, ჩაირთვება დამატებითი "
"მოვლენების მრიცხველები: </p><p>ქეშის გამოტოვებები (Cache misses) "
"ინსტრუქციების წაკითხვისას (&quot;I1mr&quot;/&quot;ILmr&quot;), </"
"p><p>მონაცემთა წაკითხვის წვდომები (&quot;Dr&quot;) და მასთან დაკავშირებული "
"ქეშის გამოტოვებები (&quot;D1mr&quot;/&quot;DLmr&quot;), </p><p>მონაცემთა "
"ჩაწერის წვდომები (&quot;Dw&quot;) და მასთან დაკავშირებული ქეშის გამოტოვებები "
"(&quot;D1mw&quot;/&quot;DLmw&quot;).</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/callgrind/callgrind_configpage.ui:36
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do branch prediction "
"simulation. Further event counters are enabled: Number of executed "
"conditional branches and related predictor misses (&quot;Bc&quot;/&quot;"
"Bcm&quot;), executed indirect jumps and related misses of the jump address "
"predictor (&quot;Bi&quot;/&quot;Bim&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>მიუთითეთ, გსურთ თუ არა დატოტვის პროგნოზირების "
"სიმულაციის ჩატარება. ჩაირთვება დამატებითი მოვლენების მრიცხველები: "
"შესრულებული პირობითი დატოტვების რაოდენობა და მასთან დაკავშირებული "
"პროგნოზატორის გამოტოვებები (&quot;Bc&quot;/&quot;Bcm&quot;), შესრულებული "
"არაპირდაპირი გადასვლები და გადასვლის მისამართის პროგნოზატორის შესაბამისი "
"გამოტოვებები (&quot;Bi&quot;/&quot;Bim&quot;).</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, callgrindAnnotateArgsLabel)
#: tools/callgrind/callgrind_configpage.ui:75
#, kde-format
msgid "callgrind_annotate parameters:"
msgstr "callgrind_annotate-ის პარამეტრები:"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchKCachegrind)
#: tools/callgrind/callgrind_configpage.ui:101
#, kde-format
msgid "Launch KCachegrind after analysis finish"
msgstr "KCachegrind-ის გაშვება ანალიზის დასრულების შემდეგ"

#: tools/callgrind/callgrind_model.cpp:287
#: tools/callgrind/callgrind_model.cpp:376
#, kde-format
msgid "Incl."
msgstr "ჩათვლ."

#: tools/callgrind/callgrind_model.cpp:288
#: tools/callgrind/callgrind_model.cpp:377
#, kde-format
msgid "Self"
msgstr "Self"

#: tools/callgrind/callgrind_model.cpp:289
#, kde-format
msgid "Called"
msgstr "გამოძახებულია"

#: tools/callgrind/callgrind_model.cpp:375
#, kde-format
msgid "Event"
msgstr "მოვლენა"

#: tools/callgrind/callgrind_model.cpp:378
#, kde-format
msgid "Short"
msgstr "მოკლე"

#: tools/callgrind/callgrind_model.cpp:500
#, kde-format
msgid "%1 per call"
msgstr "%1 თითოეული გამოძახებისას"

#: tools/callgrind/callgrind_model.cpp:501
#, kde-format
msgid "Count"
msgstr "რაოდენობა"

#: tools/callgrind/callgrind_model.cpp:504
#, kde-format
msgid "Caller"
msgstr "გამომძახებელი"

#: tools/callgrind/callgrind_model.cpp:506
#, kde-format
msgid "Callee"
msgstr "გამოძახებული"

#: tools/callgrind/callgrind_tool.cpp:35
#, kde-format
msgid "Callgrind"
msgstr "Callgrind"

#: tools/callgrind/callgrind_tool.cpp:36
#, kde-format
msgid "Callgrind (Call-Graph Generating Cache and Branch Prediction Profiler)"
msgstr ""
"Callgrind (გამოძახებების გრაფიკი, რომელიც კეშის და შტოს პროგნოზის "
"პროფაილერის გენერაციას ახდენს)"

#. i18n: ectx: property (text), widget (QPushButton, launchKCachegrindButton)
#: tools/callgrind/callgrind_view.ui:63
#, kde-format
msgid "Launch KCachegrind"
msgstr "KCachegrind-ის გაშვება"

#. i18n: ectx: attribute (title), widget (QWidget, events)
#: tools/callgrind/callgrind_view.ui:91
#, kde-format
msgid "Events"
msgstr "მოვლენები"

#. i18n: ectx: attribute (title), widget (QWidget, callers)
#: tools/callgrind/callgrind_view.ui:117
#, kde-format
msgid "Direct callers"
msgstr "პირდაპირი გამომძახებლები"

#. i18n: ectx: attribute (title), widget (QWidget, callees)
#: tools/callgrind/callgrind_view.ui:149
#, kde-format
msgid "Direct callees"
msgstr "პირდაპირი გამოძახებულები"

#. i18n: ectx: attribute (title), widget (QWidget, location)
#: tools/callgrind/callgrind_view.ui:187
#, kde-format
msgid "Location"
msgstr "დებარეობა"

#. i18n: ectx: property (text), widget (QLabel, binaryTitle)
#: tools/callgrind/callgrind_view.ui:199
#, kde-format
msgid "Binary file:"
msgstr "ბინარული ფაილი:"

#. i18n: ectx: property (text), widget (QLabel, sourceTitle)
#: tools/callgrind/callgrind_view.ui:232
#, kde-format
msgid "Source file(s):"
msgstr "კოდის ფაილები:"

#. i18n: ectx: property (text), widget (QLabel, joinListVolLabel)
#: tools/drd/drd_configpage.ui:20
#, kde-format
msgid "Joined threads memory access list volume:"
msgstr "გაერთიანებული ნაკადების მეხსიერების წვდომის სიის ზომა:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_joinListVol)
#: tools/drd/drd_configpage.ui:30
#, kde-format
msgid ""
"<html><head/><body><p>Data races that occur between a statement at the end "
"of one thread and another thread can be missed if memory access information "
"is discarded immediately after a thread has been joined. This option allows "
"to specify for how many joined threads memory access information should be "
"retained.</p></body></html>"
msgstr ""
"<html><head/><body><p>მონაცემთა დავა, რომელიც ხდება ერთი ნაკადის ბოლო "
"ოპერაციასა და სხვა ნაკადს შორის, შეიძლება შეუმჩნეველი დარჩეს, თუ "
"მეხსიერებაზე წვდომის შესახებ ინფორმაცია ნაკადის შეერთების შემდეგ "
"დაუყოვნებლივ წაიშლება. ეს პარამეტრი საშუალებას გაძლევთ, მიუთითოთ, თუ რამდენი "
"შეერთებული ნაკადისთვის უნდა იყოს შენარჩუნებული ინფორმაცია მეხსიერებაზე "
"წვდომის შესახებ.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, segmentMergingIntervalLabel)
#: tools/drd/drd_configpage.ui:37
#, kde-format
msgid "Segment merging interval:"
msgstr "სეგმენტის შერწყმის ინტერვალი:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_segmentMergingInterval)
#: tools/drd/drd_configpage.ui:44
#, kde-format
msgid ""
"<html><head/><body><p>Perform segment merging only after the specified "
"number of new segments have been created. This is an advanced configuration "
"option that allows to choose whether to minimize DRD's memory usage by "
"choosing a low value or to let DRD run faster by choosing a slightly higher "
"value. The optimal value for this parameter depends on the program being "
"analyzed. The default value works well for most programs.</p></body></html>"
msgstr ""
"<html><head/><body><p>სეგმენტების გაერთიანება მხოლოდ მას შემდეგ შესრულდება, "
"რაც შეიქმნება ახალი სეგმენტების მითითებული რაოდენობა. ეს არის გაფართოებული "
"კონფიგურაციის პარამეტრი, რომელიც საშუალებას გაძლევთ, აირჩიოთ DRD-ის "
"მეხსიერების გამოყენების მინიმიზაცია დაბალი მნიშვნელობის არჩევით, ან DRD-ის "
"უფრო სწრაფი მუშაობა ოდნავ მაღალი მნიშვნელობის არჩევით. ამ პარამეტრის "
"ოპტიმალური მნიშვნელობა დამოკიდებულია გასაანალიზებელ პროგრამაზე. ნაგულისხმევი "
"მნიშვნელობა კარგად მუშაობს პროგრამების უმეტესობისთვის.</p></body></html>"

#. i18n: ectx: attribute (title), widget (QWidget, tab)
#: tools/drd/drd_configpage.ui:75
#, kde-format
msgid "Common options"
msgstr "საერთო პარამეტრები"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:81
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether DRD detects data races on stack "
"variables. Verifying stack variables is disabled by default because most "
"programs do not share stack variables over threads.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, აღმოაჩენს თუ არა DRD მონაცემთა დავას "
"სტეკის ცვლადებზე. სტეკის ცვლადების შემოწმება ნაგულისხმევად გამორთულია, "
"რადგან პროგრამების უმეტესობა არ იყენებს სტეკის ცვლადებს სხვადასხვა ნაკადში "
"გაზიარებულად.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:84
#, kde-format
msgid "Detect data races on stack variables"
msgstr "მონაცემთა დავის დადგენა სტეკის ცვლადებზე"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:91
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report only the first data race that has "
"been detected on a memory location or all data races that have been detected "
"on a memory location.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს, მოხდეს მხოლოდ პირველი აღმოჩენილი "
"მონაცემთა დავის მოხსენება მეხსიერების მისამართზე, თუ მეხსიერების ამ "
"მისამართზე აღმოჩენილი ყველა მონაცემთა დავისა.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:94
#, kde-format
msgid "Report only the first data race"
msgstr "მხოლოდ პირველი მონაცემის დავის შეტყობინება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:104
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report races between accessing memory and "
"freeing memory. Enabling this option may cause DRD to run slightly slower. "
"Notes:</p><p>Don't enable this option when using custom memory allocators "
"that use the <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">VG_USERREQ__MALLOCLIKE_BLOCK</span> and <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span> because that would result in false "
"positives. </p><p>Don't enable this option when using reference-counted "
"objects because that will result in false positives, even when that code has "
"been annotated properly with <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE</span> and <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER</span>. See e.g. the output of the following "
"command for an example: <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">valgrind --tool=drd --free-is-write=yes drd/"
"tests/annotate_smart_pointer</span>.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს, მოხდეს თუ არა იმ დავების მოხსენება, "
"რომლებიც წარმოიქმნება მეხსიერებაზე წვდომასა და მის გათავისუფლებას შორის. ამ "
"პარამეტრის ჩართვამ შესაძლოა გამოიწვიოს DRD-ის მუშაობის უმნიშვნელო შენელება. "
"შენიშვნები:</p><p>ნუ ჩართავთ ამ პარამეტრს მეხსიერების ისეთი მორგებული "
"გამნაწილებლების გამოყენებისას, რომლებიც იყენებენ <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__MALLOCLIKE_BLOCK</span> და <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span> ბლოკებს, რადგან ეს გამოიწვევს ცრუ "
"დადებით შედეგებს. </p><p>ნუ ჩართავთ ამ პარამეტრს ობიექტების მითითებების "
"რაოდენობის აღრიცხვის (reference-counted) მექანიზმის გამოყენებისას, რადგან ეს "
"გამოიწვევს ცრუ დადებით შედეგებს მაშინაც კი, როცა კოდი სწორადაა მონიშნული "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE</span> და <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER</span> "
"მაკროსებით. მაგალითისთვის იხილეთ შემდეგი ბრძანების გამონატანი: <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">valgrind --"
"tool=drd --free-is-write=yes drd/tests/annotate_smart_pointer</span>.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:107
#, kde-format
msgid "Report races between accessing and freeing memory"
msgstr ""
"დავების შეტყობინება მეხსიერებასთან წვდომასა და მის გათავისუფლებას შორის"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_signal</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_broadcast</span> where "
"the mutex associated with the signal through <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">pthread_cond_wait</"
"span> or <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">pthread_cond_timed_wait</span> is not locked at the time the "
"signal is sent. Sending a signal without holding a lock on the associated "
"mutex is a common programming error which can cause subtle race conditions "
"and unpredictable behavior. There exist some uncommon synchronization "
"patterns however where it is safe to send a signal without holding a lock on "
"the associated mutex.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს, მოხდეს თუ არა <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_signal</span> და <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_broadcast</span> "
"ფუნქციების გამოძახებების მოხსენება მაშინ, როდესაც სიგნალის გაგზავნის "
"მომენტში დაკავშირებული მუტექსი (რომელიც ასოცირებულია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">pthread_cond_wait</"
"span> ან <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">pthread_cond_timed_wait</span> მეშვეობით) არ არის დაბლოკილი. "
"სიგნალის გაგზავნა შესაბამის მუტექსზე ბლოკის გარეშე არის გავრცელებული "
"პროგრამული შეცდომა, რამაც შეიძლება გამოიწვიოს ფარული დავის პირობები და "
"არაპროგნოზირებადი ქცევა. თუმცა არსებობს სინქრონიზაციის ზოგიერთი იშვიათი "
"შაბლონი, სადაც სიგნალის გაგზავნა დაკავშირებული მუტექსის დაბლოკვის გარეშე "
"უსაფრთხოა.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:117
#, kde-format
msgid "Report calls to unlocked signals"
msgstr "განბლოკილი სიგნალების გამოძახებების ანგარიში"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:124
#, kde-format
msgid ""
"<html><head/><body><p>Controls segment merging. Segment merging is an "
"algorithm to limit memory usage of the data race detection algorithm. "
"Disabling segment merging may improve the accuracy of the so-called 'other "
"segments' displayed in race reports but can also trigger an out of memory "
"error.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს სეგმენტების გაერთიანებას. სეგმენტების "
"გაერთიანება არის ალგორითმი, რომელიც ზღუდავს მონაცემთა დავის აღმოჩენის "
"მექანიზმის მიერ მეხსიერების გამოყენებას. სეგმენტების გაერთიანების გამორთვამ "
"შესაძლოა გააუმჯობესოს დავის ანგარიშებში ნაჩვენები ე.წ. „სხვა სეგმენტების“ "
"სიზუსტე, თუმცა ამავდროულად შესაძლოა გამოიწვიოს მეხსიერების ამოწურვის შეცდომა."
"</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:127
#, kde-format
msgid "Segment merging"
msgstr "სეგმენტების შერწყმა"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:134
#, kde-format
msgid ""
"<html><head/><body><p>Show conflicting segments in race reports. Since this "
"information can help to find the cause of a data race, this option is "
"enabled by default. Disabling this option makes the output of DRD more "
"compact.</p></body></html>"
msgstr ""
"<html><head/><body><p>დავის ანგარიშებში კონფლიქტური სეგმენტების ჩვენება. "
"ვინაიდან ამ ინფორმაციას შეუძლია დაგეხმაროთ მონაცემთა დავის მიზეზის პოვნაში, "
"ეს პარამეტრი ნაგულისხმევად ჩართულია. ამ პარამეტრის გამორთვა DRD-ის "
"გამონატანს უფრო კომპაქტურს ხდის.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:137
#, kde-format
msgid "Show conflicting segments"
msgstr "კონფლიქტური სეგმენტების ჩვენება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:144
#, kde-format
msgid ""
"<html><head/><body><p>Print stack usage at thread exit time. When a program "
"creates a large number of threads it becomes important to limit the amount "
"of virtual memory allocated for thread stacks. This option makes it possible "
"to observe how much stack memory has been used by each thread of the client "
"program.</p><p>Note: the DRD tool itself allocates some temporary data on "
"the client thread stack. The space necessary for this temporary data must be "
"allocated by the client program when it allocates stack memory, but is not "
"included in stack usage reported by DRD.</p></body></html>"
msgstr ""
"<html><head/><body><p>ნაკადის მუშაობის დასრულებისას სტეკის გამოყენების "
"შესახებ ინფორმაციის გამოტანა. როდესაც პროგრამა ქმნის ნაკადების დიდ "
"რაოდენობას, მნიშვნელოვანი ხდება ნაკადების სტეკებისთვის გამოყოფილი ვირტუალური "
"მეხსიერების რაოდენობის შეზღუდვა. ეს პარამეტრი შესაძლებელს ხდის იმის "
"დაკვირვებას, თუ რამდენი სტეკის მეხსიერება იქნა გამოყენებული კლიენტი "
"პროგრამის თითოეული ნაკადის მიერ.</p><p>შენიშვნა: DRD ინსტრუმენტი თავად "
"გამოყოფს გარკვეულ დროებით მონაცემებს კლიენტი ნაკადის სტეკზე. ამ დროებითი "
"მონაცემებისთვის საჭირო სივრცე კლიენტმა პროგრამამ უნდა გამოყოს სტეკის "
"მეხსიერების გამოყოფისას, თუმცა იგი არ არის გათვალისწინებული DRD-ის მიერ "
"მოხსენებულ სტეკის გამოყენების მაჩვენებელში.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:147
#, kde-format
msgid "Show stack usage"
msgstr "სტეკის გამოყენების ჩვენება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:154
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses DRD as "
"it assumes there is some false ordering in place between creator and created "
"thread; and therefore many types of race conditions in the application would "
"not be reported. To prevent such false ordering, this command line option is "
"set to <span style=\" font-family:'Monospace';\">yes</span> by default on "
"Solaris. All activity (loads, stores, client requests) is therefore ignored "
"during:</p><p>* pthread_create() call in the creator thread </p><p>* thread "
"creation phase (stack and TLS setup) in the created thread</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, უნდა იქნას თუ არა უგულებელყოფილი ყველა "
"აქტივობა ნაკადის შექმნისას. ნაგულისხმევად ჩართულია მხოლოდ Solaris-ზე. "
"Solaris სხვა ოპერაციულ სისტემებთან შედარებით უზრუნველყოფს უფრო მაღალ "
"გამტარუნარიანობას, პარალელიზმს და მასშტაბირებადობას, რაც მიიღწევა დაბლოკვის "
"უფრო დეტალური მექანიზმებით. ეს ნიშნავს, რომ მაგალითად, როდესაც ნაკადი "
"იქმნება glibc-ით, ნაკადის გამართვისთვის გამოიყენება მხოლოდ ერთი დიდი ბლოკი. "
"Solaris-ის libc იყენებს რამდენიმე დეტალურ ბლოკს და შემქმნელი ნაკადი "
"აგრძელებს თავის საქმიანობას რაც შეიძლება მალე, ხოლო სტეკის და TLS-ის "
"გამართვას უტოვებს შექმნილ ნაკადს. ეს ვითარება აბნევს DRD-ს, რადგან იგი "
"ვარაუდობს, რომ არსებობს გარკვეული მცდარი თანმიმდევრობა შემქმნელ და შექმნილ "
"ნაკადებს შორის; ამის გამო, აპლიკაციაში არსებული მრავალი სახის დავის პირობა "
"შესაძლოა არ იქნას მოხსენებული. ასეთი მცდარი თანმიმდევრობის თავიდან "
"ასაცილებლად, ეს ბრძანების პარამეტრი Solaris-ზე ნაგულისხმევად დაყენებულია "
"მნიშვნელობაზე <span style=\" font-family:'Monospace';\">yes</span>. "
"შესაბამისად, ყველა აქტივობა (ჩატვირთვა, შენახვა, კლიენტის მოთხოვნები) "
"უგულებელყოფილია შემდეგი პროცესებისას:</p><p>* pthread_create() გამოძახება "
"შემქმნელ ნაკადში </p><p>* ნაკადის შექმნის ფაზა (სტეკის და TLS-ის გამართვა) "
"შექმნილ ნაკადში</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:157 tools/helgrind/helgrind_configpage.ui:105
#, kde-format
msgid "Ignore thread creation"
msgstr "ნაკადის შექმნის გამოტოვება"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showInstructionPointer)
#: tools/drd/drd_configpage.ui:171 tools/helgrind/helgrind_configpage.ui:132
#: tools/memcheck/memcheck_configpage.ui:210
#, kde-format
msgid "Show stack frame instruction pointer value"
msgstr "სტეკის კადრის ინსტრუქციის მაჩვენებლის მნიშვნელობის ჩვენება"

#. i18n: ectx: attribute (title), widget (QWidget, tracesTab)
#: tools/drd/drd_configpage.ui:192
#, kde-format
msgid "Trace options"
msgstr "ტრეისის მორგება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:198
#, kde-format
msgid ""
"<html><head/><body><p>Trace all memory allocations and deallocations. May "
"produce a huge amount of output.</p></body></html>"
msgstr ""
"<html><head/><body><p>მეხსიერების ყველა გამოყოფისა და გათავისუფლების ტრეისი. "
"შეუძლია უზარმაზარი რაოდენობის ინფორმაციის გამოტანა.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:201
#, kde-format
msgid "Trace memory allocations/deallocations"
msgstr "მეხსიერების გამოყოფების/გამოყოფის გაუქმებების ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:208
#, kde-format
msgid "<html><head/><body><p>Trace all barrier activity.</p></body></html>"
msgstr ""
"<html><head/><body><p>ყველა ბარიერის აქტივობის ტრეისი.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:211
#, kde-format
msgid "Trace barrier activity"
msgstr "ტრეისის ბარიერის აქტივობა"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:218
#, kde-format
msgid ""
"<html><head/><body><p>Trace all condition variable activity.</p></body></"
"html>"
msgstr ""
"<html><head/><body><p>ყველა პირობის ცვლადის აქტივობის ტრეისი.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:221
#, kde-format
msgid "Trace condition variable activity"
msgstr "პირობის ცვლის აქტივობის ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:228
#, kde-format
msgid ""
"<html><head/><body><p>Trace all thread creation and all thread termination "
"events.</p></body></html>"
msgstr ""
"<html><head/><body><p>ნაკადის ყველა შექმნისა და შეწყვეტის მოვლენის ტრეისი.</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:231
#, kde-format
msgid "Trace thread creation/termination events"
msgstr "ნაკადის შექმნის/შეწყვეტის მოვლენების ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:238
#, kde-format
msgid ""
"<html><head/><body><p>Trace execution of the <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE()</span>, <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER()</span> and "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span> client requests.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE()</span>, "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER()</span> და <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span> კლიენტის მოთხოვნების შესრულების ტრასირებას."
"</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:241
#, kde-format
msgid "Trace execution of \"ANNOTATE_HAPPENS\" requests"
msgstr "\"ANNOTATE_HAPPENS\" მოთხოვნების შესრულების ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:248
#, kde-format
msgid "<html><head/><body><p>Trace all mutex activity.</p></body></html>"
msgstr ""
"<html><head/><body><p>ყველა მუტექსის აქტივობის ტრეისი.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:251
#, kde-format
msgid "Trace mutex activity"
msgstr "მუტექსის აქტივობის ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:258
#, kde-format
msgid ""
"<html><head/><body><p>Trace all reader-writer lock activity.</p></body></"
"html>"
msgstr ""
"<html><head/><body><p>ყველა წამკითხავი-ჩამწერი ბლოკის აქტივობის ტრეისი.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:261
#, kde-format
msgid "Trace reader-writer lock activity"
msgstr "წამკითხავი-ჩამწერი ბლოკის აქტივობის ტრეისი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:268
#, kde-format
msgid "<html><head/><body><p>Trace all semaphore activity.</p></body></html>"
msgstr ""
"<html><head/><body><p>ყველა სემაფორის აქტივობის ტრეისი.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:271
#, kde-format
msgid "Trace semaphore activity"
msgstr "სემაფორების აქტივობის ტრეკინგი"

#: tools/drd/drd_tool.cpp:35
#, kde-format
msgid "DRD"
msgstr "DRD"

#: tools/drd/drd_tool.cpp:36
#, kde-format
msgid "DRD (Thread Error Detector)"
msgstr "DRD (ნაკადის შეცდომის აღმომჩენი)"

#: tools/helgrind/helgrind_configpage.cpp:36
#, kde-format
msgid "Full"
msgstr "სრული"

#: tools/helgrind/helgrind_configpage.cpp:37
#, kde-format
msgid "Approx"
msgstr "დაახლ"

#: tools/helgrind/helgrind_configpage.cpp:38
#, kde-format
msgid "None"
msgstr "არა"

#. i18n: ectx: property (text), widget (QLabel, historyLevelLabel)
#: tools/helgrind/helgrind_configpage.ui:22
#, kde-format
msgid "History level:"
msgstr "ისტორიის დონე:"

#. i18n: ectx: property (text), widget (QLabel, conflictCacheSizeLabel)
#: tools/helgrind/helgrind_configpage.ui:29
#, kde-format
msgid "Conflict cache size:"
msgstr "კონფლიქტის კეშის ზომა:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_conflictCacheSize)
#: tools/helgrind/helgrind_configpage.ui:39
#, kde-format
msgid ""
"<html><head/><body><p>This flag only has any effect at <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
"level=full</span>.</p><p>Information about &quot;old&quot; conflicting "
"accesses is stored in a cache of limited size, with LRU-style management. "
"This is necessary because it isn't practical to store a stack trace for "
"every single memory access made by the program. Historical information on "
"not recently accessed locations is periodically discarded, to free up space "
"in the cache.</p><p>This option controls the size of the cache, in terms of "
"the number of different memory addresses for which conflicting access "
"information is stored. If you find that Helgrind is showing race errors with "
"only one stack instead of the expected two stacks, try increasing this value."
"</p><p>The minimum value is 10,000 and the maximum is 30,000,000 (thirty "
"times the default value). Increasing the value by 1 increases Helgrind's "
"memory requirement by very roughly 100 bytes, so the maximum value will "
"easily eat up three extra gigabytes or so of memory.</p></body></html>"
msgstr ""
"<html><head/><body><p>ამ ალამს გავლენა აქვს მხოლოდ იმ შემთხვევაში, თუ "
"მითითებულია <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--history-level=full</span>.</p><p>ინფორმაცია „ძველი“ "
"კონფლიქტური წვდომების შესახებ ინახება შეზღუდული ზომის ქეშში, რომელიც "
"იმართება უახლესი გამოყენების პრინციპით (LRU). ეს აუცილებელია, რადგან "
"პროგრამის მიერ შესრულებული მეხსიერებაზე თითოეული წვდომისთვის სტეკის "
"ტრესირების შენახვა პრაქტიკულად შეუძლებელია. ინფორმაცია იმ მისამართების "
"შესახებ, რომლებზეც წვდომა დიდი ხანია არ მომხდარა, პერიოდულად იშლება ქეშში "
"ადგილის გასათავისუფლებლად.</p><p>ეს პარამეტრი აკონტროლებს ქეშის ზომას იმ "
"მეხსიერების სხვადასხვა მისამართების რაოდენობის მიხედვით, რომელთათვისაც "
"ინახება კონფლიქტური წვდომის ინფორმაცია. თუ შეამჩნევთ, რომ Helgrind აჩვენებს "
"დავის შეცდომებს მხოლოდ ერთი სტეკით მოსალოდნელი ორის ნაცვლად, სცადეთ ამ "
"მნიშვნელობის გაზრდა.</p><p>მინიმალური მნიშვნელობა არის 10,000, ხოლო "
"მაქსიმალური - 30,000,000 (ნაგულისხმევ მნიშვნელობაზე ოცდაათჯერ მეტი). "
"მნიშვნელობის 1-ით გაზრდა ზრდის Helgrind-ის მეხსიერების მოთხოვნას დაახლოებით "
"100 ბაიტით, ასე რომ, მაქსიმალურმა მნიშვნელობამ შესაძლოა თავისუფლად აითვისოს "
"დამატებით სამი გიგაბაიტი მეხსიერება.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:78
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (the default), Helgrind performs lock "
"order consistency checking. For some buggy programs, the large number of "
"lock order errors reported can become annoying, particularly if you're only "
"interested in race errors. You may therefore find it helpful to disable lock "
"order checking.</p></body></html>"
msgstr ""
"<html><head/><body><p>როდესაც ეს ფუნქცია ჩართულია (რაც ნაგულისხმევია), "
"Helgrind ასრულებს დაბლოკვის თანმიმდევრობის შესაბამისობის შემოწმებას. "
"ზოგიერთი ხარვეზიანი პროგრამისთვის, დაბლოკვის თანმიმდევრობის შეცდომების დიდი "
"რაოდენობა შესაძლოა დამღლელი აღმოჩნდეს, განსაკუთრებით მაშინ, თუ თქვენ მხოლოდ "
"დავის შეცდომები გაინტერესებთ. ასეთ შემთხვევაში, შესაძლოა სასარგებლო იყოს "
"დაბლოკვის თანმიმდევრობის შემოწმების გამორთვა.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:81
#, kde-format
msgid "Track lock orders"
msgstr "დაბლოკვის შეკვეთების ტრეკინგი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:92
#, kde-format
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">By default Helgrind checks "
"all data memory accesses made by your program. This flag enables you to skip "
"checking for accesses to thread stacks (local variables). This can improve "
"performance, but comes at the cost of missing races on stack-allocated data."
"</p></body></html>"
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">ნაგულისხმევად Helgrind "
"ამოწმებს თქვენი პროგრამის მიერ მონაცემთა მეხსიერებაზე ყველა წვდომას. ეს "
"ალამი საშუალებას გაძლევთ, გამოტოვოთ ნაკადების სტეკებზე (ლოკალურ ცვლადებზე) "
"წვდომის შემოწმება. ამან შეიძლება გააუმჯობესოს წარმადობა, თუმცა სტეკზე "
"განთავსებულ მონაცემებზე დავების გამოტოვების ფასად.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:95
#, kde-format
msgid "Check stack refs"
msgstr "სტეკის მიმართვების შემოწმება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/helgrind/helgrind_configpage.ui:102
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses "
"Helgrind as it assumes there is some false ordering in place between creator "
"and created thread; and therefore many types of race conditions in the "
"application would not be reported. To prevent such false ordering, this "
"command line option is set to yes by default on Solaris. All activity "
"(loads, stores, client requests) is therefore ignored during:</p><p>* "
"pthread_create() call in the creator thread</p><p>* thread creation phase "
"(stack and TLS setup) in the created thread</p><p>Also new memory allocated "
"during thread creation is untracked, that is race reporting is suppressed "
"there. DRD does the same thing implicitly. This is necessary because Solaris "
"libc caches many objects and reuses them for different threads and that "
"confuses Helgrind.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, უნდა იქნას თუ არა უგულებელყოფილი ყველა "
"აქტივობა ნაკადის შექმნისას. ნაგულისხმევად ჩართულია მხოლოდ Solaris-ზე. "
"Solaris სხვა ოპერაციულ სისტემებთან შედარებით უზრუნველყოფს უფრო მაღალ "
"გამტარუნარიანობას, პარალელიზმს და მასშტაბირებადობას, რაც მიიღწევა დაბლოკვის "
"უფრო დეტალური (fine-grained) მექანიზმებით. ეს ნიშნავს, რომ მაგალითად, "
"როდესაც ნაკადი იქმნება glibc-ის ქვეშ, ნაკადის გამართვისთვის გამოიყენება "
"მხოლოდ ერთი დიდი ბლოკი. Solaris libc იყენებს რამდენიმე დეტალურ ბლოკს და "
"შემქმნელი ნაკადი აგრძელებს თავის საქმიანობას რაც შეიძლება მალე, ხოლო სტეკის "
"და TLS-ის გამართვას უტოვებს შექმნილ ნაკადს. ეს ვითარება აბნევს Helgrind-ს, "
"რადგან იგი ვარაუდობს, რომ არსებობს გარკვეული მცდარი თანმიმდევრობა შემქმნელ "
"და შექმნილ ნაკადებს შორის; ამის გამო, აპლიკაციაში არსებული მრავალი სახის "
"დავის პირობა შესაძლოა არ იქნას მოხსენებული. ასეთი მცდარი თანმიმდევრობის "
"თავიდან ასაცილებლად, ეს ბრძანების პარამეტრი Solaris-ზე ნაგულისხმევად "
"დაყენებულია მნიშვნელობაზე yes. შესაბამისად, ყველა აქტივობა (ჩატვირთვა, "
"შენახვა, კლიენტის მოთხოვნები) უგულებელყოფილია შემდეგი პროცესებისას:</p><p>* "
"pthread_create() გამოძახება შემქმნელ ნაკადში</p><p>* ნაკადის შექმნის ფაზა "
"(სტეკის და TLS-ის გამართვა) შექმნილ ნაკადში</p><p>ასევე, ნაკადის შექმნისას "
"გამოყოფილი ახალი მეხსიერება არ კონტროლდება, რაც ნიშნავს, რომ იქ დავების "
"მოხსენება შეჩერებულია. DRD იმავეს აკეთებს იმპლიციტურად. ეს აუცილებელია, "
"რადგან Solaris libc ახდენს მრავალი ობიექტის ქეშირებას და მათ ხელახლა იყენებს "
"სხვადასხვა ნაკადისთვის, რაც აბნევს Helgrind-ს.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:115
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (not the default), Helgrind treats "
"freeing of heap memory as if the memory was written immediately before the "
"free. This exposes races where memory is referenced by one thread, and freed "
"by another, but there is no observable synchronization event to ensure that "
"the reference happens before the free.</p><p>This functionality is new in "
"Valgrind 3.7.0, and is regarded as experimental. It is not enabled by "
"default because its interaction with custom memory allocators is not well "
"understood at present. User feedback is welcomed.</p></body></html>"
msgstr ""
"<html><head/><body><p>როდესაც ეს ფუნქცია ჩართულია (რაც არ არის "
"ნაგულისხმევი), Helgrind განიხილავს დინამიური მეხსიერების (heap) "
"გათავისუფლებას ისე, თითქოს მეხსიერებაში ჩაწერა მოხდა უშუალოდ "
"გათავისუფლებამდე. ეს გამოავლენს დავებს, როდესაც მეხსიერებას იყენებს ერთი "
"ნაკადი, ხოლო ათავისუფლებს მეორე, მაგრამ არ არსებობს სინქრონიზაციის "
"შესამჩნევი მოვლენა, რომელიც უზრუნველყოფდა მეხსიერებაზე წვდომას მის "
"გათავისუფლებამდე.</p><p>ეს ფუნქციონალი ახალია Valgrind 3.7.0 ვერსიაში და "
"ითვლება ექსპერიმენტულად. იგი არ არის ჩართული ნაგულისხმევად, რადგან მისი "
"ურთიერთქმედება მეხსიერების მორგებულ გამნაწილებლებთან ამჟამად კარგად არ არის "
"შესწავლილი. მომხმარებელთა უკუკავშირი მისასალმებელია.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:118
#, kde-format
msgid "Free is write (experimental)"
msgstr "გათავისუფლება ჩაწერაა (ექსპერიმენტული)"

#: tools/helgrind/helgrind_tool.cpp:35
#, kde-format
msgid "Helgrind"
msgstr "Helgrind"

#: tools/helgrind/helgrind_tool.cpp:36
#, kde-format
msgid "Helgrind (Thread Error Detector)"
msgstr "Helgrind (ნაკადის შეცდომის აღმომჩენი)"

#: tools/massif/massif_configpage.cpp:39
#, kde-format
msgid "CPU instructions"
msgstr "პროცესორის ინსტრუქციები"

#: tools/massif/massif_configpage.cpp:40
#, kde-format
msgid "Milliseconds"
msgstr "მილიწამი"

#: tools/massif/massif_configpage.cpp:41
#, kde-format
msgid "Bytes allocated"
msgstr "გამოყოფილი ბაიტი"

#. i18n: ectx: property (text), widget (QLabel, timeUnitLabel)
#: tools/massif/massif_configpage.ui:25
#, kde-format
msgid "Time unit:"
msgstr "დროის ერთეული:"

#. i18n: ectx: property (text), widget (QLabel, snapshotTreeDepthLabel)
#: tools/massif/massif_configpage.ui:32
#, kde-format
msgid "Snapshot tree depth:"
msgstr "სწრაფი ასლის ხის სიღრმე:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_snapshotTreeDepth)
#: tools/massif/massif_configpage.ui:42
#, kde-format
msgid ""
"<html><head/><body><p>Maximum depth of the allocation trees recorded for "
"detailed snapshots. Increasing it will make Massif run somewhat more slowly, "
"use more memory, and produce bigger output files.</p></body></html>"
msgstr ""
"<html><head/><body><p>დეტალური სწრაფი ასლებისთვის ჩაწერილი მეხსიერების "
"გამოყოფის ხეების მაქსიმალური სიღრმე. ამ მნიშვნელობის გაზრდა Massif-ს ოდნავ "
"შეანელებს, გაზრდის მეხსიერების გამოყენებას და წარმოქმნის უფრო დიდ გამონატან "
"ფაილებს.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, thresholdLabel)
#: tools/massif/massif_configpage.ui:49
#, kde-format
msgid "Threshold:"
msgstr "ზღვარი:"

#. i18n: ectx: property (text), widget (QLabel, peakInaccuracyLabel)
#: tools/massif/massif_configpage.ui:59
#, kde-format
msgid "Peak inaccuracy:"
msgstr "პიკური უზუსტობა:"

#. i18n: ectx: property (text), widget (QLabel, maximumSnapshotsLabel)
#: tools/massif/massif_configpage.ui:69
#, kde-format
msgid "Maximum snapshots:"
msgstr "მაქს. სწრაფი ასლები:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maximumSnapshots)
#: tools/massif/massif_configpage.ui:79
#, kde-format
msgid ""
"<html><head/><body><p>The maximum number of snapshots recorded. If set to N, "
"for all programs except very short-running ones, the final number of "
"snapshots will be between N/2 and N.</p></body></html>"
msgstr ""
"<html><head/><body><p>ჩაწერილი სწრაფი ასლების მაქსიმალური რაოდენობა. თუ "
"მითითებულია N, ყველა პროგრამისთვის, გარდა ძალიან ხანმოკლეებისა, სწრაფი "
"ასლების საბოლოო რაოდენობა იქნება N/2-სა და N-ს შორის.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, detailedSnapshotsFrequencyLabel)
#: tools/massif/massif_configpage.ui:86
#, kde-format
msgid "Detailed snapshot frequency:"
msgstr "დეტალური სწრაფი ასლის სიხშირე:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_detailedSnapshotsFrequency)
#: tools/massif/massif_configpage.ui:96
#, kde-format
msgid ""
"<html><head/><body><p>Frequency of detailed snapshots. With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--detailed-"
"freq=1</span>, every snapshot is detailed.</p></body></html>"
msgstr ""
"<html><head/><body><p>დეტალური სწრაფი ასლების სიხშირე. პარამეტრით <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"detailed-freq=1</span>, ყველა სწრაფი ასლი დეტალურია.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/massif/massif_configpage.ui:103
#: tools/memcheck/memcheck_configpage.ui:121
#, kde-format
msgid "E&xtra parameters:"
msgstr "&დამატებითი პარამეტრები:"

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_threshold)
#: tools/massif/massif_configpage.ui:123
#, kde-format
msgid ""
"<html><head/><body><p>The significance threshold for heap allocations, as a "
"percentage of total memory size. Allocation tree entries that account for "
"less than this will be aggregated. Note that this should be specified in "
"tandem with ms_print's option of the same name.</p></body></html>"
msgstr ""
"<html><head/><body><p>დინამიკური მეხსიერების გამოყოფის მნიშვნელოვნების "
"ზღვარი, მთლიანი მეხსიერების ზომის პროცენტული მაჩვენებლით. გამოყოფის ხის ის "
"ჩანაწერები, რომლებიც ამ ზღვარზე ნაკლებს შეადგენენ, დაჯგუფდება. "
"გაითვალისწინეთ, რომ ეს პარამეტრი უნდა მიეთითოს ms_print-ის იმავე "
"სახელწოდების პარამეტრთან ერთად.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_peakInaccuracy)
#: tools/massif/massif_configpage.ui:136
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Massif does not necessarily record the actual global "
"memory allocation peak; by default it records a peak only when the global "
"memory allocation size exceeds the previous peak by at least 1.0%. This is "
"because there can be many local allocation peaks along the way, and doing a "
"detailed snapshot for every one would be expensive and wasteful, as all but "
"one of them will be later discarded. This inaccuracy can be changed (even to "
"0.0%) via this option, but Massif will run drastically slower as the number "
"approaches zero.</p></body></html>"
msgstr ""
"<html><head/><body><p>Massif ყოველთვის არ აფიქსირებს გლობალური მეხსიერების "
"გამოყოფის რეალურ პიკს; ნაგულისხმევად, იგი აფიქსირებს პიკს მხოლოდ მაშინ, როცა "
"მეხსიერების გამოყოფის გლობალური ზომა წინა პიკს სულ მცირე 1.0%-ით აჭარბებს. "
"ეს იმიტომ ხდება, რომ პროცესში შეიძლება ბევრი ლოკალური პიკი დაფიქსირდეს, ხოლო "
"თითოეულისთვის დეტალური სწრაფი ასლის გაკეთება რესურსების მხრივ ძვირი და "
"არაეფექტური იქნებოდა, რადგან ერთის გარდა ყველა მათგანი მოგვიანებით მაინც "
"წაიშლება. ამ უზუსტობის შეცვლა (თუნდაც 0.0%-მდე) შესაძლებელია ამ პარამეტრით, "
"თუმცა მნიშვნელობის ნულთან მიახლოებისას Massif მკვეთრად შენელდება.</p></"
"body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:158
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether heap profiling should be done.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>მიუთითებს, მოხდება თუ არა მეხსიერების გროვის "
"პროფილრება.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:161
#, kde-format
msgid "Profile heap"
msgstr "დინამიკური მეხსიერების პროფილირება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:171
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether stack profiling should be done. This "
"option slows Massif down greatly, and so is off by default. Note that Massif "
"assumes that the main stack has size zero at start-up. This is not true, but "
"doing otherwise accurately is difficult. Furthermore, starting at zero "
"better indicates the size of the part of the main stack that a user program "
"actually has control over.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს, უნდა მოხდეს თუ არა სტეკის პროფილირება. "
"ეს პარამეტრი მნიშვნელოვნად ანელებს Massif-ის მუშაობას, ამიტომ ნაგულისხმევად "
"გამორთულია. გაითვალისწინეთ, რომ Massif უშვებს, თითქოს მთავარი სტეკის ზომა "
"გაშვებისას ნულის ტოლია. ეს ასე არ არის, თუმცა რეალური ზომის ზუსტად "
"განსაზღვრა სირთულეებთანაა დაკავშირებული. გარდა ამისა, ნულიდან ათვლა უკეთ "
"აჩვენებს მთავარი სტეკის იმ ნაწილის ზომას, რომელზეც მომხმარებლის პროგრამას "
"რეალურად აქვს კონტროლი.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:174
#, kde-format
msgid "Profile stack (slows profiling down greatly)"
msgstr "სტეკის პროფილირება (პროფილებას მნიშვნელოვნად ანელებს)"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:181
#, kde-format
msgid ""
"<html><head/><body><p>Tells Massif to profile memory at the page level "
"rather than at the malloc'd block level.</p></body></html>"
msgstr ""
"<html><head/><body><p>მიუთითებს Massif-ს, რომ აწარმოოს მეხსიერების "
"პროფილირება გვერდების დონეზე და არა malloc-ით გამოყოფილი ბლოკების დონეზე.</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:184
#, kde-format
msgid "Pages as heap"
msgstr "გვერდები მეხსიერების გროვის სახით"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/massif/massif_configpage.ui:191
#, kde-format
msgid ""
"<html><head/><body><p>&quot;Pages as heap&quot; cannot be used together with "
"&quot;Profile stack&quot;.</p></body></html>"
msgstr ""
"<html><head/><body><p>&quot;გვერდები, როგორც მეხსიერების გროვა&quot; და "
"&quot;სტეკის პროფილირება&quot; ერთდროულად ვერ იქნება გამოყენებული.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchVisualizer)
#: tools/massif/massif_configpage.ui:214
#, kde-format
msgid "Launch Massif Visualizer after analysis finish"
msgstr "Massif ვიზუალიზატორის გაშვება ანალიზის დასრულების შემდეგ"

#: tools/massif/massif_model.cpp:129
#, kde-format
msgid "Snapshot"
msgstr "სნეპშოტი"

#: tools/massif/massif_model.cpp:132
#, kde-format
msgid "Time"
msgstr "დრო"

#: tools/massif/massif_model.cpp:135
#, kde-format
msgid "Heap"
msgstr "მეხსიერების გროვა"

#: tools/massif/massif_model.cpp:138
#, kde-format
msgid "Heap (extra)"
msgstr "მეხსიერების გროვა (დამატებით)"

#: tools/massif/massif_model.cpp:141
#, kde-format
msgid "Stack"
msgstr "დასტა"

#: tools/massif/massif_tool.cpp:35
#, kde-format
msgid "Massif"
msgstr "Massif"

#: tools/massif/massif_tool.cpp:36
#, kde-format
msgid "Massif (Heap Profiler)"
msgstr "Massif (მეხსიერების გროვის პროფაილერი)"

#. i18n: ectx: property (text), widget (QLabel, snapshotsLabel)
#: tools/massif/massif_view.ui:36
#, kde-format
msgid "Snapshots"
msgstr "სწრაფი ასლები"

#. i18n: ectx: property (text), widget (QLabel, treesLabel)
#: tools/massif/massif_view.ui:56
#, kde-format
msgid "Heap trees"
msgstr "მეხსიერების გროვის ხეები"

#. i18n: ectx: property (text), widget (QPushButton, launchVisualizerButton)
#: tools/massif/massif_view.ui:70
#, kde-format
msgid "Launch visualizer"
msgstr "ვიზუალიზატორის გაშვება"

#: tools/memcheck/memcheck_configpage.cpp:43
#, kde-format
msgid "definite"
msgstr "განსა"

#: tools/memcheck/memcheck_configpage.cpp:44
#, kde-format
msgid "possible"
msgstr "შესაძლო"

#: tools/memcheck/memcheck_configpage.cpp:45
#, kde-format
msgid "indirect"
msgstr "არაპირდაპირი"

#: tools/memcheck/memcheck_configpage.cpp:46
#, kde-format
msgid "reachable"
msgstr "ხელმისაწვდომი"

#. i18n text ?
#: tools/memcheck/memcheck_configpage.cpp:50
#, kde-format
msgid "stdstring"
msgstr "სტანდარტულისტრიქონი"

#: tools/memcheck/memcheck_configpage.cpp:51
#, kde-format
msgid "length64"
msgstr "სიგრძე64"

#: tools/memcheck/memcheck_configpage.cpp:52
#, kde-format
msgid "newarray"
msgstr "ახალიმასივი"

#: tools/memcheck/memcheck_configpage.cpp:53
#, kde-format
msgid "multipleinheritance"
msgstr "ერთზემეტიმემკვიდრეობა"

#: tools/memcheck/memcheck_configpage.cpp:56
#, kde-format
msgid "high"
msgstr "მაღალი"

#: tools/memcheck/memcheck_configpage.cpp:57
#, kde-format
msgid "medium"
msgstr "საშუალო"

#: tools/memcheck/memcheck_configpage.cpp:58
#, kde-format
msgid "low"
msgstr "დაბალი"

#: tools/memcheck/memcheck_configpage.cpp:60
#, kde-format
msgid "alloc"
msgstr "alloc"

#: tools/memcheck/memcheck_configpage.cpp:61
#, kde-format
msgid "free"
msgstr "თავისუფალია"

#: tools/memcheck/memcheck_configpage.cpp:62
#, kde-format
msgid "alloc-and-free"
msgstr "alloc-and-free"

#: tools/memcheck/memcheck_configpage.cpp:63
#, kde-format
msgid "alloc-then-free"
msgstr "alloc-then-free"

#. i18n: ectx: property (text), widget (QLabel, leakResolutionLabel)
#: tools/memcheck/memcheck_configpage.ui:25
#, kde-format
msgid "Leak resolution:"
msgstr "გაჟონვის გარჩევადობა:"

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_leakResolution)
#: tools/memcheck/memcheck_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>When doing leak checking, determines how willing "
"Memcheck is to consider different backtraces to be the same for the purposes "
"of merging multiple leaks into a single leak report. When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">low</"
"span>, only the first two entries need match. When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">med</span>, four "
"entries have to match. When <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">high</span>, all entries need to match.</"
"p><p>For hardcore leak debugging, you probably want to use <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> together with <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--num-callers=40</span> or some such "
"large number.</p><p>Note that the <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--leak-resolution</span> setting does "
"not affect Memcheck's ability to find leaks. It only changes how the results "
"are presented.</p></body></html>"
msgstr ""
"<html><head/><body><p>მეხსიერების გაჟონვის შემოწმებისას განსაზღვრავს, "
"რამდენად „მზადაა“ Memcheck, რომ სხვადასხვა უკუტრეისი მიიჩნიოს იდენტურად, რომ "
"რამდენიმე გაჟონვა ერთ ანგარიშში გააერთიანოს. როდესაც დაყენებულია მნიშვნელობა "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">დაბალი</span>, მხოლოდ პირველი ორი ჩანაწერის დამთხვევაა საჭირო. "
"მნიშვნელობაზე <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">med</span>, ოთხი ჩანაწერი უნდა დაემთხვეს. ხოლო <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">high</"
"span> მნიშვნელობისას, ყველა ჩანაწერი უნდა იყოს იდენტური.</p><p>გაჟონვების "
"საფუძვლიანი გამართვისთვის, სავარაუდოდ, დაგჭირდებათ <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> პარამეტრის გამოყენება <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--num-callers=40</"
"span>-თან ან სხვა მსგავს დიდ რიცხვთან ერთად.</p><p>გაითვალისწინეთ, რომ <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"leak-resolution</span> პარამეტრი გავლენას არ ახდენს Memcheck-ის უნარზე, "
"იპოვოს გაჟონვები. ის მხოლოდ შედეგების წარმოდგენის ფორმას ცვლის.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QLabel, showLeakKindsLabel)
#: tools/memcheck/memcheck_configpage.ui:39
#, kde-format
msgid "Show leak kinds:"
msgstr "გაჟონვის ტიპების ჩვენება:"

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_showLeakKinds)
#: tools/memcheck/memcheck_configpage.ui:46
#, kde-format
msgid "Specifies the leak kinds to show."
msgstr "მიუთითებს საჩვენებელი გაჟონვის ტიპებს."

#. i18n: ectx: property (text), widget (QLabel, leakCheckHeuristicsLabel)
#: tools/memcheck/memcheck_configpage.ui:59
#, kde-format
msgid "Used heuristics:"
msgstr "გამოყენებული ევრისტიკა:"

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_leakCheckHeuristics)
#: tools/memcheck/memcheck_configpage.ui:66
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the set of leak check heuristics to be used "
"during leak searches. The heuristics control which interior pointers to a "
"block cause it to be considered as reachable.</p></body></html>"
msgstr ""
"<html><head/><body><p>განსაზღვრავს გაჟონვის შემოწმების ევრისტიკების ნაკრებს, "
"რომლებიც გამოყენებული იქნება გაჟონვების ძიებისას. ევრისტიკები აკონტროლებენ, "
"თუ ბლოკის რომელი შიდა მიმთითებლები განაპირობებენ მის მიჩნევას მიღწევადად.</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, keepStacktracesLabel)
#: tools/memcheck/memcheck_configpage.ui:76
#, kde-format
msgid "Stacktraces keeping:"
msgstr "სტეკის ტრეისების შენარჩუნება:"

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_keepStacktraces)
#: tools/memcheck/memcheck_configpage.ui:83
#, kde-format
msgid ""
"<html><head/><body><p>Controls which stack trace(s) to keep for malloc'd and/"
"or free'd blocks. </p><p>With <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, a stack trace is "
"recorded at allocation time, and is associated with the block. When the "
"block is freed, a second stack trace is recorded, and this replaces the "
"allocation stack trace. As a result, any &quot;use after free&quot; errors "
"relating to this block can only show a stack trace for where the block was "
"freed. </p><p>With <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">alloc-and-free</span>, both allocation and the "
"deallocation stack traces for the block are stored. Hence a &quot;use after "
"free&quot; error will show both, which may make the error easier to "
"diagnose. Compared to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, this setting "
"slightly increases Valgrind's memory use as the block contains two "
"references instead of one. </p><p>With <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc</span>, only "
"the allocation stack trace is recorded (and reported). With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, "
"only the deallocation stack trace is recorded (and reported). These values "
"somewhat decrease Valgrind's memory and cpu usage. They can be useful "
"depending on the error types you are searching for and the level of detail "
"you need to analyze them. For example, if you are only interested in memory "
"leak errors, it is sufficient to record the allocation stack traces. </"
"p><p>With <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">none</span>, no stack traces are recorded for malloc and "
"free operations. If your program allocates a lot of blocks and/or allocates/"
"frees from many different stack traces, this can significantly decrease cpu "
"and/or memory required. Of course, few details will be reported for errors "
"related to heap blocks. </p><p>Note that once a stack trace is recorded, "
"Valgrind keeps the stack trace in memory even if it is not referenced by any "
"block. Some programs (for example, recursive algorithms) can generate a huge "
"number of stack traces. If Valgrind uses too much memory in such "
"circumstances, you can reduce the memory required with the options <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"keep-stacktraces</span> and/or by using a smaller value for the option <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"num-callers</span>. </p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, თუ რომელი სტეკის ტრესირება (ან "
"ტრესირებები) უნდა იქნას შენახული გამოყოფილი (malloc'd) ან/და გათავისუფლებული "
"(free'd) ბლოკებისთვის. </p><p>რეჟიმში <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc-then-free</"
"span>, სტეკის ტრესირება იწერება გამოყოფის დროს და ასოცირდება ბლოკთან. "
"როდესაც ბლოკი თავისუფლდება, იწერება მეორე ტრესირება, რომელიც ანაცვლებს "
"გამოყოფისას ჩაწერილ ინფორმაციას. შედეგად, ამ ბლოკთან დაკავშირებული "
"ნებისმიერი „გამოყენება გათავისუფლების შემდეგ“ (use after free) შეცდომა "
"აჩვენებს მხოლოდ იმ ადგილს, სადაც მოხდა ბლოკის გათავისუფლება.</p><p>რეჟიმში "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">alloc-and-free</span>, ინახება ბლოკის გამოყოფის და გათავისუფლების ორივე "
"ტრესირება. შესაბამისად, „გამოყენება გათავისუფლების შემდეგ“ შეცდომა აჩვენებს "
"ორივეს, რაც აადვილებს პრობლემის დიაგნოსტიკას. <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc-then-free</"
"span>-სთან შედარებით, ეს პარამეტრი ოდნავ ზრდის Valgrind-ის მეხსიერების "
"გამოყენებას, რადგან ბლოკი შეიცავს ორ მიმთითებელს ერთის ნაცვლად.</"
"p><p>რეჟიმში <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">alloc</span>, იწერება (და მოხსენდება) მხოლოდ გამოყოფის "
"ტრესირება. რეჟიმში <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">free</span>, იწერება მხოლოდ გათავისუფლების ტრესირება. "
"ეს მნიშვნელობები გარკვეულწილად ამცირებს Valgrind-ის მეხსიერებისა და "
"პროცესორის დატვირთვას. ისინი შეიძლება სასარგებლო იყოს იმის მიხედვით, თუ "
"რომელი ტიპის შეცდომებს ეძებთ და ანალიზისთვის რა დონის დეტალიზაცია გჭირდებათ. "
"მაგალითად, თუ მხოლოდ მეხსიერების გაჟონვის შეცდომები გაინტერესებთ, საკმარისია "
"გამოყოფის ტრეს"

#. i18n: ectx: property (text), widget (QLabel, freelistVolLabel)
#: tools/memcheck/memcheck_configpage.ui:90
#, kde-format
msgid "Freelist maximum size:"
msgstr "თავისუფალი ბლოკების სიის მაქს. ზომა:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistVol)
#: tools/memcheck/memcheck_configpage.ui:100
#, kde-format
msgid ""
"<html><head/><body><p>When the client program releases memory using <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span> (in <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">C</span>) or <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete</span> (<span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">C++</span>), that "
"memory is not immediately made available for re-allocation. Instead, it is "
"marked inaccessible and placed in a queue of freed blocks. The purpose is to "
"defer as long as possible the point at which freed-up memory comes back into "
"circulation. This increases the chance that Memcheck will be able to detect "
"invalid accesses to blocks for some significant period of time after they "
"have been freed.</p><p>This option specifies the maximum total size, in "
"bytes, of the blocks in the queue. The default value is twenty million "
"bytes. Increasing this increases the total amount of memory used by Memcheck "
"but may detect invalid uses of freed blocks which would otherwise go "
"undetected.</p></body></html>"
msgstr ""
"<html><head/><body><p>როდესაც კლიენტის პროგრამა ათავისუფლებს მეხსიერებას "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span> (C-ში) ან <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">delete</span> (C++-ში) ოპერაციების "
"გამოყენებით, ეს მეხსიერება დაუყოვნებლივ არ ხდება ხელმისაწვდომი ხელახალი "
"გამოყოფისთვის. ამის ნაცვლად, იგი ინიშნება როგორც მიუწვდომელი და თავსდება "
"გათავისუფლებული ბლოკების რიგში. მიზანია, მაქსიმალურად გადავადდეს ის მომენტი, "
"როდესაც გათავისუფლებული მეხსიერება კვლავ ბრუნვაში დაბრუნდება. ეს ზრდის იმის "
"შანსს, რომ Memcheck-მა შეძლოს ბლოკებზე არავალიდური წვდომის აღმოჩენა მათი "
"გათავისუფლებიდან გარკვეული დროის განმავლობაში.</p><p>ეს პარამეტრი "
"განსაზღვრავს რიგში არსებული ბლოკების მაქსიმალურ საერთო ზომას ბაიტებში. "
"ნაგულისხმევი მნიშვნელობა არის ოცი მილიონი ბაიტი. ამ მნიშვნელობის გაზრდა "
"ზრდის Memcheck-ის მიერ გამოყენებული მეხსიერების მთლიან რაოდენობას, მაგრამ "
"საშუალებას იძლევა აღმოაჩინოს გათავისუფლებული ბლოკების არასწორი გამოყენების "
"ისეთი შემთხვევები, რომლებიც სხვაგვარად შეუმჩნეველი დარჩებოდა.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QLabel, freelistBigBlocksLabel)
#: tools/memcheck/memcheck_configpage.ui:107
#, kde-format
msgid "Freelist big-blocks:"
msgstr "თავისუფალი ბლოკების სიის დიდი ბლოკები:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistBigBlocks)
#: tools/memcheck/memcheck_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>When making blocks from the queue of freed blocks "
"available for re-allocation, Memcheck will in priority re-circulate the "
"blocks with a size greater or equal to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--freelist-big-"
"blocks</span>. This ensures that freeing big blocks (in particular freeing "
"blocks bigger than <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">--freelist-vol</span>) does not immediately lead to a "
"re-circulation of all (or a lot of) the small blocks in the free list. In "
"other words, this option increases the likelihood to discover dangling "
"pointers for the &quot;small&quot; blocks, even when big blocks are freed.</"
"p><p>Setting a value of 0 means that all the blocks are re-circulated in a "
"FIFO order.</p></body></html>"
msgstr ""
"<html><head/><body><p>გათავისუფლებული ბლოკების რიგიდან ხელახალი "
"გამოყოფისთვის ბლოკების მომზადებისას, Memcheck პრიორიტეტულად დააბრუნებს "
"ბრუნვაში იმ ბლოკებს, რომელთა ზომა მეტია ან ტოლია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--freelist-big-"
"blocks</span> მნიშვნელობაზე. ეს უზრუნველყოფს, რომ დიდი ბლოკების "
"გათავისუფლებამ (კერძოდ, <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--freelist-vol</span>-ზე დიდი ბლოკების) "
"დაუყოვნებლივ არ გამოიწვიოს გათავისუფლებულთა სიაში არსებული ყველა (ან ბევრი) "
"მცირე ბლოკის ხელახალი მიმოქცევა. სხვა სიტყვებით, ეს პარამეტრი ზრდის „მცირე“ "
"ბლოკებისთვის დაკიდებული მიმთითებლების აღმოჩენის ალბათობას, მაშინაც კი, "
"როდესაც დიდი ბლოკები თავისუფლდება.</p><p>0 მნიშვნელობის დაყენება ნიშნავს, "
"რომ ყველა ბლოკი ბრუნვაში ბრუნდება FIFO (პირველი შემოსული - პირველი გასული) "
"პრინციპით.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:150
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck reports uses of undefined "
"value errors. Set this to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">no</span> if you don't want to see "
"undefined value errors. It also has the side effect of speeding up Memcheck "
"somewhat.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, უნდა მოახსენოს თუ არა Memcheck-მა "
"განუსაზღვრელი მნიშვნელობების გამოყენების შეცდომები. მიანიჭეთ მნიშვნელობა "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">no</span>, თუ არ გსურთ ამ შეცდომების ნახვა. ამას ასევე აქვს თანმდევი "
"ეფექტი — Memcheck-ის მუშაობის გარკვეულწილად დაჩქარება.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:153
#, kde-format
msgid "Show undefined values usage"
msgstr "განუსაზღვრელი მნიშვნელობების გამოყენების ჩვენება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:163
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Memcheck checks that heap blocks are "
"deallocated using a function that matches the allocating function. That is, "
"it expects <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">free</span> to be used to deallocate blocks allocated by "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">malloc</span>, <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">delete</span> for blocks allocated by <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>, "
"and <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">delete[]</span> for blocks allocated by <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span>. If a "
"mismatch is detected, an error is reported. This is in general important "
"because in some environments, freeing with a non-matching function can cause "
"crashes.</p><p>There is however a scenario where such mismatches cannot be "
"avoided. That is when the user provides implementations of <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">new[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">malloc</span> and of <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">free</span>, and these functions are "
"asymmetrically inlined. For example, imagine that <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span> is "
"inlined but <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">new[]</span> is not. The result is that Memcheck &quot;"
"sees&quot; all <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">delete[]</span> calls as direct calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, even "
"when the program source contains no mismatched calls.</p><p>This causes a "
"lot of confusing and irrelevant error reports. <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--show-mismatched-"
"frees=no</span> disables these checks. It is not generally advisable to "
"disable them, though, because you may miss real errors as a result.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>როდესაც ეს პარამეტრი ჩართულია, Memcheck ამოწმებს, რომ "
"დინამიური მეხსიერების ბლოკების დეალოკაცია ხდება იმ ფუნქციით, რომელიც "
"შეესაბამება გამოყოფის (allocation) ფუნქციას. კერძოდ, იგი მოელის, რომ ფუნქცია "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span> გამოყენებული იქნება ფუნქცია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">malloc</span>-ით "
"გამოყოფილი ბლოკებისთვის, ფუნქცია <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete</span> — ფუნქცია <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>-ით "
"გამოყოფილისთვის, ხოლო ფუნქცია <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">delete[]</span> — ფუნქცია <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span>-"
"ით გამოყოფილისთვის. შეუსაბამობის აღმოჩენის შემთხვევაში, მოხსენდება შეცდომა. "
"ეს ზოგადად მნიშვნელოვანია, რადგან ზოგიერთ გარემოში შეუსაბამო ფუნქციით "
"მეხსიერების გათავისუფლებამ შეიძლება გამოიწვიოს პროგრამის კრაში.</p><p>თუმცა, "
"არსებობს სცენარი, როდესაც ასეთი შეუსაბამობები გარდაუვალია. ეს ხდება მაშინ, "
"როდესაც მომხმარებელი თავად ქმნის ფუნქცია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new</span>/<span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">new[]</span>-ის იმპლემენტაციებს, რომლებიც იძახებენ ფუნქცია <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">malloc</span>-"
"ს, ხოლო ფუნქცია <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">delete</span>/<span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete[]</span> იძახებს ფუნქცია <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span>-ს და ეს ფუნქციები ასიმეტრიულად არის ჩაშენებული (inlined). "
"მაგალითად, წარმოიდგინეთ, რომ ფუნქცია <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete[]</span> ჩაშენებულია, ხოლო "
"ფუნქცია <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">new[]</span> — არა. შედეგად, Memcheck ყველა <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span>-ის "
"გამოძახებას „ხედავს“, როგორც ფუნქცია <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">free</span>-ს პირდაპირ გამოძახებას, "
"მაშინაც კი, როდესაც პროგრამის საწყისი კოდი არ შეიცავს შეუსაბამო გამოძახებებს."
"</p><p>ეს იწვევს ბევრ დამაბნეველ და უადგილო შეცდომის ანგარიშს. პარამეტრი "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--show-mismatched-frees=no</span> თიშავს ამ შემოწმებებს. თუმცა, მათი "
"გათიშვა ზოგადად არ არის რეკომენდებული, რადგან ამის გამო შეიძლება გამოგეპაროთ "
"რეალური შეცდომები.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:166
#, kde-format
msgid "Show mismatched frees"
msgstr "შეუსაბამო გათავისუფლებების ჩვენება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:173
#, kde-format
msgid ""
"<html><head/><body><p>Controls how Memcheck handles 32-, 64-, 128- and 256-"
"bit naturally aligned loads from addresses for which some bytes are "
"addressable and others are not. When <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">yes</span>, such loads do not produce "
"an address error. Instead, loaded bytes originating from illegal addresses "
"are marked as uninitialised, and those corresponding to legal addresses are "
"handled in the normal way.</p><p>When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">no</span>, loads "
"from partially invalid addresses are treated the same as loads from "
"completely invalid addresses: an illegal-address error is issued, and the "
"resulting bytes are marked as initialised.</p><p>Note that code that behaves "
"in this way is in violation of the ISO C/C++ standards, and should be "
"considered broken. If at all possible, such code should be fixed.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, თუ როგორ მართავს Memcheck 32, 64, 128 და "
"256 ბიტიან ბუნებრივად გასწორებულ (naturally aligned) ჩატვირთვებს იმ "
"მისამართებიდან, რომელთა ზოგიერთი ბაიტი მისაწვდომია, ხოლო სხვები — არა. "
"როდესაც არჩეულია <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">yes</span>, ასეთი ჩატვირთვები არ იწვევს მისამართის "
"შეცდომას. ამის ნაცვლად, არალეგალური მისამართებიდან წამოღებული ბაიტები "
"ინიშნება როგორც არაინიციალიზებული, ხოლო ლეგალური მისამართების შესაბამისი "
"ბაიტები მუშავდება ჩვეულებრივი წესით.</p><p>როდესაც არჩეულია <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">no</span>, "
"ნაწილობრივ არავალიდური მისამართებიდან ჩატვირთვა განიხილება ისევე, როგორც "
"სრულად არავალიდური მისამართებიდან: გაიცემა არალეგალური მისამართის შეცდომა, "
"ხოლო მიღებული ბაიტები ინიშნება როგორც ინიციალიზებული.</p><p>გაითვალისწინეთ, "
"რომ კოდი, რომელიც ასე იქცევა, არღვევს ISO C/C++ სტანდარტებს და უნდა "
"ჩაითვალოს დაზიანებულად. თუ ეს შესაძლებელია, ასეთი კოდი უნდა გამოსწორდეს.</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:176
#, kde-format
msgid "Allow partial loads"
msgstr "ნაწილობრივი ჩატვირთვების ჩვენება"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:183
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck tracks the origin of "
"uninitialised values. By default, it does not, which means that although it "
"can tell you that an uninitialised value is being used in a dangerous way, "
"it cannot tell you where the uninitialised value came from. This often makes "
"it difficult to track down the root problem.</p><p>When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">yes</"
"span>, Memcheck keeps track of the origins of all uninitialised values. "
"Then, when an uninitialised value error is reported, Memcheck will try to "
"show the origin of the value. An origin can be one of the following four "
"places: a heap block, a stack allocation, a client request, or miscellaneous "
"other sources (eg, a call to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">brk</span>).</p><p>For uninitialised values "
"originating from a heap block, Memcheck shows where the block was allocated. "
"For uninitialised values originating from a stack allocation, Memcheck can "
"tell you which function allocated the value, but no more than that -- "
"typically it shows you the source location of the opening brace of the "
"function. So you should carefully check that all of the function's local "
"variables are initialised properly. </p><p>Performance overhead: origin "
"tracking is expensive. It halves Memcheck's speed and increases memory use "
"by a minimum of 100MB, and possibly more. Nevertheless it can drastically "
"reduce the effort required to identify the root cause of uninitialised value "
"errors, and so is often a programmer productivity win, despite running more "
"slowly. </p><p>Accuracy: Memcheck tracks origins quite accurately. To avoid "
"very large space and time overheads, some approximations are made. It is "
"possible, although unlikely, that Memcheck will report an incorrect origin, "
"or not be able to identify any origin. </p><p>Note that the combination "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--track-origins=yes</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--undef-value-errors=no</span> is "
"nonsensical. Memcheck checks for and rejects this combination at startup.</"
"p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, უნდა ადევნოს თუ არა თვალი Memcheck-მა "
"არაინიციალიზებული მნიშვნელობების წარმოშობას. ნაგულისხმევად, ის ამას არ "
"აკეთებს, რაც ნიშნავს, რომ მიუხედავად იმისა, რომ მას შეუძლია გითხრათ, რომ "
"არაინიციალიზებული მნიშვნელობა გამოიყენება სახიფათო გზით, მას არ შეუძლია "
"გითხრათ, საიდან გაჩნდა ეს მნიშვნელობა. ეს ხშირად ართულებს პრობლემის ძირეული "
"მიზეზის პოვნას.</p><p>როდესაც არჩეულია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">yes</span>, "
"Memcheck აღრიცხავს ყველა არაინიციალიზებული მნიშვნელობის წარმოშობას. ამ "
"შემთხვევაში, როდესაც არაინიციალიზებული მნიშვნელობის შეცდომა დაფიქსირდება, "
"Memcheck შეეცდება აჩვენოს მისი სათავე. წარმოშობის ადგილი შეიძლება იყოს "
"ოთხიდან ერთ-ერთი: დინამიური მეხსიერების (heap) ბლოკი, სტეკზე გამოყოფა, "
"კლიენტის მოთხოვნა ან სხვა სხვადასხვა წყარო (მაგალითად, ფუნქცია <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">brk</span>-"
"ის გამოძახება).</p><p>დინამიური მეხსიერების ბლოკიდან წარმოშობილი "
"მნიშვნელობებისთვის Memcheck აჩვენებს, თუ სად მოხდა ბლოკის გამოყოფა. სტეკიდან "
"წარმოშობილი მნიშვნელობებისთვის Memcheck გეტყვით, თუ რომელმა ფუნქციამ გამოყო "
"ეს მნიშვნელობა, მაგრამ მეტს ვერაფერს — როგორც წესი, ის აჩვენებს ფუნქციის "
"გამხსნელი ფრჩხილის ადგილმდებარეობას კოდში. ამიტომ, ყურადღებით უნდა "
"შეამოწმოთ, რომ ფუნქციის ყველა ლოკალური ცვლადი სწორად არის ინიციალიზებული.</"
"p><p>წარმადობა: წარმოშობის მიკვლევა რესურსების მხრივ ძვირია. ის ანახევრებს "
"Memcheck-ის სიჩქარეს და ზრდის მეხსიერების მოხმარებას მინიმუმ 100MB-ით, "
"შესაძლოა მეტითაც. მიუხედავად ამისა, მას შეუძლია მკვეთრად შეამციროს "
"არაინიციალიზებული მნიშვნელობის შეცდომების ძირეული მიზეზის დასადგენად საჭირო "
"ძალისხმევა, რაც ხშირად პროგრამისტის პროდუქტიულობის ზრდას ნიშნავს, შენელებული "
"მუშაობის მიუხედავად.</p><p>სიზუსტე: Memcheck საკმაოდ ზუსტად ადევნებს თვალს "
"წარმოშობას. მეხსიერების და დროის ძალიან დიდი დანახარჯების თავიდან "
"ასაცილებლად, ზოგიერთი მიახლოება მაინც გამოიყენება. შესაძლებელია, თუმცა "
"ნაკლებად სავარაუდო, რომ Memcheck-მა არასწორი წარმოშობა აჩვენოს ან საერთოდ "
"ვერ დაადგინოს იგი.</p><p>გაითვალისწინეთ, რომ კომბინაცია <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--track-"
"origins=yes</span> და <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--undef-value-errors=no</span> აზრს "
"მოკლებულია. Memcheck ამოწმებს და ბლოკავს ამ კომბინაციას გაშვებისას.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:186
#, kde-format
msgid "Track origins of all uninitialised values"
msgstr "ყველა არაინიციალიზებული მნიშვნელობის წყაროს ტრეკინგი"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:193
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck should employ more precise "
"but also more expensive (time consuming) algorithms when checking the "
"definedness of a value. The default setting is not to do that and it is "
"usually sufficient. However, for highly optimised code valgrind may "
"sometimes incorrectly complain. Invoking valgrind with <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--expensive-"
"definedness-checks=yes</span> helps but comes at a performance cost. Runtime "
"degradation of 25% have been observed but the extra cost depends a lot on "
"the application at hand.</p></body></html>"
msgstr ""
"<html><head/><body><p>აკონტროლებს, უნდა გამოიყენოს თუ არა Memcheck-მა უფრო "
"ზუსტი, მაგრამ ასევე უფრო ძვირი (დროში ტევადი) ალგორითმები მნიშვნელობის "
"განსაზღვრულობის შემოწმებისას. ნაგულისხმევი პარამეტრი ამას არ ითვალისწინებს "
"და ეს ჩვეულებრივ საკმარისია. თუმცა, მაღალ დონეზე ოპტიმიზებული კოდის "
"შემთხვევაში, Valgrind-მა შეიძლება ზოგჯერ შეცდომით დააფიქსიროს პრობლემა. "
"Valgrind-ის გაშვება პარამეტრით <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--expensive-definedness-checks=yes</span> "
"შველის ამ საკითხს, მაგრამ წარმადობის ხარჯზე. დაფიქსირებულია პროგრამის "
"მუშაობის 25%-იანი შენელება, თუმცა დამატებითი დანახარჯი დიდწილად კონკრეტულ "
"აპლიკაციაზეა დამოკიდებული.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:196
#, kde-format
msgid "Expensive definedness checks"
msgstr "ძვირიანი აღწერილობის შემოწმებები"

#: tools/memcheck/memcheck_tool.cpp:35
#, kde-format
msgid "Memcheck"
msgstr "მეხსიერების შემოწმება"

#: tools/memcheck/memcheck_tool.cpp:36
#, kde-format
msgid "Memcheck (Memory Error Detector)"
msgstr "Memcheck (მეხსიერების შეცდომის აღმომჩენი)"

#: toolviewfactory.cpp:47
#, kde-format
msgid "Valgrind Output"
msgstr "Valgrind-ის გამოტანილი ინფორმაცია"

#: toolviewfactory.cpp:49
#, kde-format
msgid ""
"<b>Valgrind</b><p>Shows the output of valgrind. Valgrind detects:<br/>use of "
"uninitialized memory;<br/>reading/writing memory after it has been free'd;"
"<br/>reading/writing off the end of malloc'd blocks;<br/>reading/writing "
"inappropriate areas on the stack;<br/>memory leaks &mdash; where pointers to "
"malloc'd blocks are lost forever;<br/>passing of uninitialised and/or "
"unaddressable memory to system calls;<br/>mismatched use of malloc/new/new "
"[] vs free/delete/delete [];<br/>some abuses of the POSIX pthread API.</p>"
msgstr ""
"<b>Valgrind</b><p>აჩვენებს Valgrind-ის გამონატანს. Valgrind აღმოაჩენს:<br/"
">არაინიციალიზებული მეხსიერების გამოყენებას;<br/>მეხსიერების წაკითხვას/"
"ჩაწერას მისი გათავისუფლების შემდეგ;<br/>მეხსიერების წაკითხვას/ჩაწერას malloc-"
"ით გამოყოფილი ბლოკების საზღვრებს გარეთ;<br/>სტეკის შეუსაბამო არეებზე "
"წაკითხვას/ჩაწერას;<br/>მეხსიერების გაჟონვებს — შემთხვევებს, როდესაც malloc-"
"ით გამოყოფილი ბლოკების მიმთითებლები სამუდამოდ იკარგება;<br/"
">არაინიციალიზებული ან/და მიუწვდომელი მეხსიერების გადაცემას სისტემური "
"გამოძახებებისთვის;<br/>ფუნქცია malloc/new/new[]-ის შეუსაბამო გამოყენებას "
"ფუნქცია free/delete/delete[]-ის მიმართ;<br/>POSIX pthread API-ს ბოროტად "
"გამოყენების ზოგიერთ შემთხვევას.</p>"
