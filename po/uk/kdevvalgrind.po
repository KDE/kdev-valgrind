# Translation of kdevvalgrind.po to Ukrainian
# Copyright (C) 2008-2018 This_file_is_part_of_KDE
# This file is distributed under the license LGPL version 2.1 or
# version 3 or later versions approved by the membership of KDE e.V.
#
# Yuri Chornoivan <yurchor@ukr.net>, 2008, 2009, 2010, 2011, 2012, 2013, 2015, 2016, 2017, 2018, 2021.
msgid ""
msgstr ""
"Project-Id-Version: kdevvalgrind\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-11-05 12:28+0000\n"
"PO-Revision-Date: 2021-07-03 08:57+0300\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian <kde-i18n-uk@kde.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 20.12.0\n"
"Plural-Forms: nplurals=4; plural=n==1 ? 3 : n%10==1 && n%100!=11 ? 0 : n"
"%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"

#: config/globalconfigpage.cpp:45 launchmode.cpp:47 plugin.cpp:68
#: plugin.cpp:213 problemmodel.cpp:54 problemmodel.cpp:67
#, kde-format
msgid "Valgrind"
msgstr "Valgrind"

#: config/globalconfigpage.cpp:50
#, kde-format
msgid "Configure Valgrind Settings"
msgstr "Налаштувати параметри Valgrind"

#. i18n: ectx: property (title), widget (QGroupBox, pathsGroupBox)
#: config/globalconfigpage.ui:29
#, kde-format
msgid "Valgrind executables"
msgstr "Виконувані файли Valgrind"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:35
#, kde-format
msgid "Valgrind:"
msgstr "Valgrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:55
#, kde-format
msgid "callgrind_annotate:"
msgstr "callgrind_annotate:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:75
#, kde-format
msgid "cg_annotate:"
msgstr "cg_annotate:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox)
#: config/globalconfigpage.ui:98
#, kde-format
msgid "Visualizers executables"
msgstr "Виконувані файли візуалізатора"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:104
#, kde-format
msgid "KCachegrind:"
msgstr "KCachegrind:"

#. i18n: ectx: property (text), widget (QLabel)
#: config/globalconfigpage.ui:124
#, kde-format
msgid "Massif Visualizer:"
msgstr "Візуалізатор Massif:"

#. i18n: ectx: property (title), widget (QGroupBox, outputGroupBox_2)
#: config/globalconfigpage.ui:147
#, kde-format
msgid "Output"
msgstr "Виведення"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:153
#, kde-format
msgid ""
"<html><head/><body><p>Valgrind messages will be displayed in the output view "
"during analysis.</p><p>Useful for plugin debugging.</p></body></html>"
msgstr ""
"<html><head/><body><p>Повідомлення Valgrind буде показано на панелі "
"виведення під час аналізу.</p><p>Корисно для діагностики додатків.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showValgrindOutput)
#: config/globalconfigpage.ui:156
#, kde-format
msgid "Show valgrind output during analysis"
msgstr "Показувати виведення valgrind під час аналізу"

#: core/job.cpp:138
#, kde-format
msgid "%1 Analysis (%2)"
msgstr "Аналіз %1 (%2)"

#: core/job.cpp:217
#, kde-format
msgid "Failed to start valgrind from \"%1\"."
msgstr "Не вдалося запустити valgrind з «%1»."

#: core/job.cpp:224
#, kde-format
msgid "Valgrind crashed."
msgstr "Аварійне завершення Valgrind."

#: core/job.cpp:229
#, kde-format
msgid "Valgrind process timed out."
msgstr "Перевищення часу затримки у процесі Valgrind."

#: core/job.cpp:233
#, kde-format
msgid "Write to Valgrind process failed."
msgstr "Запис до процесу Valgrind зазнав невдачі."

#: core/job.cpp:237
#, kde-format
msgid "Read from Valgrind process failed."
msgstr "Читання з процесу Valgrind зазнало невдачі."

#: core/job.cpp:255 core/job.cpp:301
#, kde-format
msgid "Please review your Valgrind launch configuration."
msgstr "Будь ласка, перегляньте ваші налаштування запуску Valgrind."

#: core/job.cpp:257
#, kde-format
msgid "Unknown Valgrind process error."
msgstr "Невідома помилка у процесі Valgrind."

#: core/job.cpp:263 core/job.cpp:303 core/private/xmlparser.cpp:262
#: core/utils.cpp:124
#, kde-format
msgid "Valgrind Error"
msgstr "Помилка Valgrind"

#: core/job.cpp:279
#, kde-format
msgid "Executing command: "
msgstr "Виконуємо команду: "

#: core/job.cpp:297
#, kde-format
msgid "Failed to execute the command:"
msgstr "Не вдалося виконати команду:"

#: core/private/common_configpage.cpp:30
#, kde-format
msgid "Valgrind Common Settings"
msgstr "Загальні параметри Valgrind"

#. i18n: ectx: property (text), widget (QLabel, numCallersLabel)
#: core/private/common_configpage.ui:22
#, kde-format
msgid "Display stac&k to depth:"
msgstr "Показувати стек на &глибину:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_numCallers)
#: core/private/common_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the maximum number of entries shown in stack "
"traces that identify program locations. Note that errors are commoned up "
"using only the top four function locations (the place in the current "
"function, and that of its three immediate callers). So this doesn't affect "
"the total number of errors reported.</p><p>The maximum value for this is "
"500. Note that higher settings will make Valgrind run a bit more slowly and "
"take a bit more memory, but can be useful when working with programs with "
"deeply-nested call chains.</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає максимальну кількість записів, які буде "
"показано у трасуваннях стека для ідентифікації місць у програмі. Зауважте, "
"що помилки узагальнюються лише за верхніми чотирма записами функцій (місцем "
"у поточній функції і місцями у трьох функціях, які можуть її викликати). "
"Отже, це не вплине на загальну кількість помилок у звіті.</p><p>Максимальним "
"значенням цього параметра є 500. Зауважте, що більші значення дещо "
"уповільнять роботу Valgrind і призведуть до більшого споживання пам’яті. "
"Втім, збільшення значення може бути корисним для дослідження програм із "
"ланцюжками викликів зі значним рівнем вкладеності.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, maxStackframeLabel)
#: core/private/common_configpage.ui:39
#, kde-format
msgid " Maximum size of a stack frame:"
msgstr "Максимальний розмір кадру стека:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maxStackframe)
#: core/private/common_configpage.ui:49
#, kde-format
msgid ""
"<html><head/><body><p>The maximum size of a stack frame. If the stack "
"pointer moves by more than this amount then Valgrind will assume that the "
"program is switching to a different stack.</p><p>You may need to use this "
"option if your program has large stack-allocated arrays. Valgrind keeps "
"track of your program's stack pointer. If it changes by more than the "
"threshold amount, Valgrind assumes your program is switching to a different "
"stack, and Memcheck behaves differently than it would for a stack pointer "
"change smaller than the threshold. Usually this heuristic works well. "
"However, if your program allocates large structures on the stack, this "
"heuristic will be fooled, and Memcheck will subsequently report large "
"numbers of invalid stack accesses. This option allows you to change the "
"threshold to a different value.</p><p>You should only consider use of this "
"option if Valgrind's debug output directs you to do so. In that case it will "
"tell you the new threshold you should specify.</p><p>In general, allocating "
"large structures on the stack is a bad idea, because you can easily run out "
"of stack space, especially on systems with limited memory or which expect to "
"support large numbers of threads each with a small stack, and also because "
"the error checking performed by Memcheck is more effective for heap-"
"allocated data than for stack-allocated data. If you have to use this "
"option, you may wish to consider rewriting your code to allocate on the heap "
"rather than on the stack.</p></body></html>"
msgstr ""
"<html><head/><body><p>Максимальний розмір кадру стека. Якщо зміщення "
"вказівника стека перевищить це значення, Valgrind припускатиме, що програма "
"перемкнулася на інший стек.</p><p>Цей параметр може знадобитися, якщо "
"програма використовує великі масиви, які розміщуються у стеку. Valgrind "
"стежитиме за вказівником стека вашої програми. Якщо він змінюватиметься на "
"значення, яке є більшим за порогове, Valgrind вважатиме, що ваша програма "
"перемкнулася на інший стек, а Memcheck поводитиметься інакше, ніж він це "
"робить, коли зміна вказівника стека є меншою за порогову. Зазвичай, така "
"евристика працює як слід. Втім, якщо ваша програма розміщує великі структури "
"у стеку, евристика не спрацює, а Memcheck почне повідомляти про велику "
"кількість некоректних доступів до стека. За допомогою цього параметра ви "
"можете змінити порогове значення.</p><p>Вам варто змінювати типове значення, "
"лише якщо діагностичні повідомлення Valgrind просять вас це зробити. "
"Програма сама має повідомити вам нове порогове значення, яке слід вказати.</"
"p><p>Загалом, не варто розміщувати великі структури даних у стеку, оскільки "
"ви ризикуватимете виходом за простір стека, особливо у системах із малим "
"обсягом пам’яті або системах, де реалізовано підтримку великої кількості "
"потоків виконання з малими стеками для кожного потоку. Ще однією причиною "
"відмовитися від такого розміщення даних є те, що пошук помилок, який "
"виконується Memcheck, є ефективнішим для даних, які розміщено у «купі», а не "
"у стеку. Якщо виникає потреба у використанні цього параметра, варто "
"подумати, чи не слід переписати код програми так, щоб дані розміщувалися у "
"«купі» пам’яті, а не у стеку.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: core/private/common_configpage.ui:56
#, kde-format
msgid "&Extra parameters:"
msgstr "Додаткові &параметри:"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:82
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Valgrind stops reporting errors after "
"10,000,000 in total, or 1,000 different ones, have been seen. This is to "
"stop the error tracking machinery from becoming a huge performance overhead "
"in programs with many errors.</p></body></html>"
msgstr ""
"<html><head/><body><p>Якщо увімкнено, Valgrind припинить звітувати про "
"помилки, якщо їхня кількість перевищить 10000000 будь-яких або 1000 різних "
"записів. Так зроблено для того, щоб механізми стеження за помилками не "
"заважали створенню звітів у програмах з багатьма помилками.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_errorLimit)
#: core/private/common_configpage.ui:85
#, kde-format
msgid "Limit errors if too many"
msgstr "Обмежувати повідомлення щодо помилок, якщо їх багато"

#: core/private/xmlparser.cpp:258
#, kde-format
msgid "Valgrind XML Parsing: error at line %1, column %2: %3"
msgstr "Розбір XML Valgrind: помилка у рядку %1, позиція %2: %3"

#: core/utils.cpp:47
#, kde-format
msgid "Instruction Fetch"
msgstr "Отримання інструкцій"

#: core/utils.cpp:48
#, kde-format
msgid "Data Read Access"
msgstr "Доступ для читання даних"

#: core/utils.cpp:49
#, kde-format
msgid "Data Write Access"
msgstr "Доступ для запису даних"

#: core/utils.cpp:50
#, kde-format
msgid "L1 Instr. Fetch Miss"
msgstr "Похибка отримання інстр. L1"

#: core/utils.cpp:51
#, kde-format
msgid "L1 Data Read Miss"
msgstr "Похибка читання даних L1"

#: core/utils.cpp:52
#, kde-format
msgid "L1 Data Write Miss"
msgstr "Похибка запису даних L1"

#: core/utils.cpp:53
#, kde-format
msgid "LL Instr. Fetch Miss"
msgstr "Похибка отримання інстр. LL"

#: core/utils.cpp:54
#, kde-format
msgid "LL Data Read Miss"
msgstr "Похибка читання даних LL"

#: core/utils.cpp:55
#, kde-format
msgid "LL Data Write Miss"
msgstr "Похибка запису даних LL"

#: core/utils.cpp:57
#, kde-format
msgid "Conditional Branch"
msgstr "Умовне відгалуження"

#: core/utils.cpp:58
#, kde-format
msgid "Mispredicted Cond. Branch"
msgstr "Помилково прогнозоване ум. відгалуження"

#: core/utils.cpp:59
#, kde-format
msgid "Indirect Branch"
msgstr "Непряме відгалуження"

#: core/utils.cpp:60
#, kde-format
msgid "Mispredicted Ind. Branch"
msgstr "Помилково прогнозоване непр. відгалуження"

#: core/utils.cpp:116
#, kde-format
msgid "Failed to start visualizer from \"%1\"."
msgstr "Не вдалося запустити візуалізатор з «%1»."

#: core/utils.cpp:118
#, kde-format
msgid "Check your settings and install the visualizer if necessary."
msgstr ""
"Перевірте, чи правильно вказано параметри, і, якщо потрібно, встановіть "
"візуалізатор."

#: core/utils.cpp:120
#, kde-format
msgid "Error during visualizer execution:"
msgstr "Помилка під час спроби запустити візуалізатор:"

#: core/widgets/menubutton.cpp:95 tools/memcheck/memcheck_configpage.cpp:64
#, kde-format
msgid "none"
msgstr "none"

#: core/widgets/menubutton.cpp:98
#, kde-format
msgid "all"
msgstr "усі"

#. i18n: ectx: Menu (valgrind)
#: kdevvalgrind.rc:6
#, kde-format
msgid "Run Valgrind Analysis"
msgstr "Виконати аналіз Valgrind"

#: plugin.cpp:79
#, kde-format
msgid "Run %1"
msgstr "Виконати %1"

#: problemmodel.cpp:68
#, kde-format
msgctxt "@info:tooltip"
msgid "Re-Run %1 Analysis for Current Launch Configuration"
msgstr "Повторно виконати аналіз %1 для поточних налаштувань запуску"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of cache access and "
"miss counts.</p></body></html>"
msgstr ""
"<html><head/><body><p>Вмикає або вимикає збирання даних щодо кількості "
"доступів до кешу та промахів у кеші.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_cacheSim)
#: tools/cachegrind/cachegrind_configpage.ui:26
#: tools/callgrind/callgrind_configpage.ui:26
#, kde-format
msgid "Cache simulation"
msgstr "Імітатор кешу"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:36
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Enables or disables collection of branch instruction "
"and misprediction counts. By default this is disabled as it slows Cachegrind "
"down by approximately 25%. Note that you cannot specify <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--cache-sim=no</"
"span> and <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--branch-sim=no</span> together, as that would leave "
"Cachegrind with no information to collect.</p></body></html>"
msgstr ""
"<html><head/><body><p>Вмикає або вимикає збирання даних щодо кількості "
"розгалуження інструкцій та помилкових передбачено розгалужень. Типово, таке "
"збирання вимкнено, оскільки воно уповільнює роботу Cachegrind приблизно на "
"25 %. Зауважте, що не можна одночасно використовувати <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--cache-sim=no</"
"span> і <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">--branch-sim=no</span>, оскільки це залишає Cachegrind без даних.</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_branchSim)
#: tools/cachegrind/cachegrind_configpage.ui:39
#: tools/callgrind/callgrind_configpage.ui:39
#, kde-format
msgid "Branch simulation"
msgstr "Імітатор гілки"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/cachegrind/cachegrind_configpage.ui:49
#, kde-format
msgid ""
"You cannot disable both cache and branch simulation, as that would leave "
"Cachegrind with no information to collect."
msgstr ""
"Не можна одночасно вимикати імітацію кешу та розгалуження, оскільки це не "
"дасть Cachegrind зібрати потрібні дані."

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:74
#: tools/callgrind/callgrind_configpage.ui:58 tools/drd/drd_configpage.ui:51
#: tools/helgrind/helgrind_configpage.ui:46
#, kde-format
msgid "Extra parameters:"
msgstr "Додаткові параметри:"

#. i18n: ectx: property (text), widget (QLabel, cgAnnotateArgsLabel)
#: tools/cachegrind/cachegrind_configpage.ui:91
#, kde-format
msgid "cg_annotate parameters:"
msgstr "Параметри cg_annotate:"

#: tools/cachegrind/cachegrind_model.cpp:155
#: tools/callgrind/callgrind_model.cpp:289
#, kde-format
msgid "Function"
msgstr "Функція"

#: tools/cachegrind/cachegrind_tool.cpp:35
#, kde-format
msgid "Cachegrind"
msgstr "Cachegrind"

#: tools/cachegrind/cachegrind_tool.cpp:36
#, kde-format
msgid "Cachegrind (Cache and Branch-Prediction Profiler)"
msgstr "Cachegrind (засіб профілювання кешу і передбачення розгалужень)"

#. i18n: ectx: property (placeholderText), widget (QLineEdit, searchEdit)
#: tools/cachegrind/cachegrind_view.ui:31 tools/callgrind/callgrind_view.ui:40
#, kde-format
msgid "Search..."
msgstr "Шукати…"

#. i18n: ectx: property (text), widget (QCheckBox, percenageValues)
#: tools/cachegrind/cachegrind_view.ui:41 tools/callgrind/callgrind_view.ui:53
#, kde-format
msgid "Percentage values"
msgstr "Значення у відсотках"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_cacheSim)
#: tools/callgrind/callgrind_configpage.ui:23
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do full cache simulation. By "
"default, only instruction read accesses will be counted (&quot;Ir&quot;). "
"With cache simulation, further event counters are enabled: </p><p>Cache "
"misses on instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), </p><p>data "
"read accesses (&quot;Dr&quot;) and related cache misses (&quot;D1mr&quot;/"
"&quot;DLmr&quot;), </p><p>data write accesses (&quot;Dw&quot;) and related "
"cache misses (&quot;D1mw&quot;/&quot;DLmw&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи потрібна вам повна імітація кешу. Типово, "
"до уваги братимуться лише доступи для читання інструкцій («Ir»). Якщо кеш "
"імітуватиметься, можна буде використовувати інші лічильники подій: </"
"p><p>Промахи у кеші при читанні інструкцій («I1mr»/«ILmr»), </p><p>доступи "
"до читання даних («Dr») та пов’язані із ними промахи у кеші («D1mr»/«DLmr»), "
"</p><p>доступи до запису даних («Dw») та пов’язані із ними промахи у кеші "
"(«D1mw»/«DLmw»).</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_branchSim)
#: tools/callgrind/callgrind_configpage.ui:36
#, kde-format
msgid ""
"<html><head/><body><p>Specify if you want to do branch prediction "
"simulation. Further event counters are enabled: Number of executed "
"conditional branches and related predictor misses (&quot;Bc&quot;/&quot;"
"Bcm&quot;), executed indirect jumps and related misses of the jump address "
"predictor (&quot;Bi&quot;/&quot;Bim&quot;).</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи потрібна вам імітація передбачення "
"розгалужень. Якщо імітацію буде увімкнено, можна буде скористатися такими "
"лічильниками подій: кількість виконаних умовних розгалужень та пов’язаних із "
"ними помилок передбачення («Bc»/«Bcm»), виконаних опосередкованих переходів "
"і пов’язаних із ними помилок у передбаченні адрес переходів («Bi»/«Bim»).</"
"p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, callgrindAnnotateArgsLabel)
#: tools/callgrind/callgrind_configpage.ui:75
#, kde-format
msgid "callgrind_annotate parameters:"
msgstr "Параметри callgrind_annotate:"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchKCachegrind)
#: tools/callgrind/callgrind_configpage.ui:101
#, kde-format
msgid "Launch KCachegrind after analysis finish"
msgstr "Запустити KCachegrind після завершення аналізу"

#: tools/callgrind/callgrind_model.cpp:286
#: tools/callgrind/callgrind_model.cpp:375
#, kde-format
msgid "Incl."
msgstr "Вкл."

#: tools/callgrind/callgrind_model.cpp:287
#: tools/callgrind/callgrind_model.cpp:376
#, kde-format
msgid "Self"
msgstr "Власний"

#: tools/callgrind/callgrind_model.cpp:288
#, kde-format
msgid "Called"
msgstr "Викликається"

#: tools/callgrind/callgrind_model.cpp:374
#, kde-format
msgid "Event"
msgstr "Подія"

#: tools/callgrind/callgrind_model.cpp:377
#, kde-format
msgid "Short"
msgstr "Короткий"

#: tools/callgrind/callgrind_model.cpp:499
#, kde-format
msgid "%1 per call"
msgstr "%1 на виклик"

#: tools/callgrind/callgrind_model.cpp:500
#, kde-format
msgid "Count"
msgstr "Кількість"

#: tools/callgrind/callgrind_model.cpp:503
#, kde-format
msgid "Caller"
msgstr "Зовнішній виклик"

#: tools/callgrind/callgrind_model.cpp:505
#, kde-format
msgid "Callee"
msgstr "Внутрішній виклик"

#: tools/callgrind/callgrind_tool.cpp:35
#, kde-format
msgid "Callgrind"
msgstr "Callgrind"

#: tools/callgrind/callgrind_tool.cpp:36
#, kde-format
msgid "Callgrind (Call-Graph Generating Cache and Branch Prediction Profiler)"
msgstr ""
"Callgrind (засіб профілювання кешу і передбачення розгалужень із можливістю "
"створення графу викликів)"

#. i18n: ectx: property (text), widget (QPushButton, launchKCachegrindButton)
#: tools/callgrind/callgrind_view.ui:63
#, kde-format
msgid "Launch KCachegrind"
msgstr "Запустити KCachegrind"

#. i18n: ectx: attribute (title), widget (QWidget, events)
#: tools/callgrind/callgrind_view.ui:91
#, kde-format
msgid "Events"
msgstr "Події"

#. i18n: ectx: attribute (title), widget (QWidget, callers)
#: tools/callgrind/callgrind_view.ui:117
#, kde-format
msgid "Direct callers"
msgstr "Безпосередні зовнішні виклики"

#. i18n: ectx: attribute (title), widget (QWidget, callees)
#: tools/callgrind/callgrind_view.ui:149
#, kde-format
msgid "Direct callees"
msgstr "Безпосередні внутрішні виклики"

#. i18n: ectx: attribute (title), widget (QWidget, location)
#: tools/callgrind/callgrind_view.ui:187
#, kde-format
msgid "Location"
msgstr "Розташування"

#. i18n: ectx: property (text), widget (QLabel, binaryTitle)
#: tools/callgrind/callgrind_view.ui:199
#, kde-format
msgid "Binary file:"
msgstr "Бінарний файл:"

#. i18n: ectx: property (text), widget (QLabel, sourceTitle)
#: tools/callgrind/callgrind_view.ui:232
#, kde-format
msgid "Source file(s):"
msgstr "Файл(и) коду:"

#. i18n: ectx: property (text), widget (QLabel, joinListVolLabel)
#: tools/drd/drd_configpage.ui:20
#, kde-format
msgid "Joined threads memory access list volume:"
msgstr "Обсяг списку доступів до пам’яті з’єднаних потоків:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_joinListVol)
#: tools/drd/drd_configpage.ui:30
#, kde-format
msgid ""
"<html><head/><body><p>Data races that occur between a statement at the end "
"of one thread and another thread can be missed if memory access information "
"is discarded immediately after a thread has been joined. This option allows "
"to specify for how many joined threads memory access information should be "
"retained.</p></body></html>"
msgstr ""
"<html><head/><body><p>Конкуренцію за дані, яка трапляється між інструкцією "
"наприкінці одного з потоків виконання і іншим потоком, може бути пропущено, "
"якщо дані щодо доступу до пам’яті буде відкинуто одразу після з’єднання "
"потоку виконання з основним потоком. За допомогою цього пункту можна "
"вказати, яку кількість дій із доступу до пам’яті з боку з’єднаних потоків "
"слід зберігати.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, segmentMergingIntervalLabel)
#: tools/drd/drd_configpage.ui:37
#, kde-format
msgid "Segment merging interval:"
msgstr "Інтервал об’єднання сегментів:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_segmentMergingInterval)
#: tools/drd/drd_configpage.ui:44
#, kde-format
msgid ""
"<html><head/><body><p>Perform segment merging only after the specified "
"number of new segments have been created. This is an advanced configuration "
"option that allows to choose whether to minimize DRD's memory usage by "
"choosing a low value or to let DRD run faster by choosing a slightly higher "
"value. The optimal value for this parameter depends on the program being "
"analyzed. The default value works well for most programs.</p></body></html>"
msgstr ""
"<html><head/><body><p>Виконати об’єднання сегментів лише після створення "
"вказаної кількості нових сегментів. Це параметр розширеного налаштовування, "
"за допомогою якого можна зробити вибір між мінімізацією споживання пам’яті "
"DRD (малі значення параметра) і пришвидшенням роботи DRD (трохи більші за "
"типове значення). Оптимальне значення цього параметра залежить від програми, "
"яку ви аналізуєте. Для більшості програм достатньо скористатися типовим "
"значенням.</p></body></html>"

#. i18n: ectx: attribute (title), widget (QWidget, tab)
#: tools/drd/drd_configpage.ui:75
#, kde-format
msgid "Common options"
msgstr "Загальні параметри"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:81
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether DRD detects data races on stack "
"variables. Verifying stack variables is disabled by default because most "
"programs do not share stack variables over threads.</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи буде DRD виявляти конкуренцію за дані "
"для стекових змінних. Типово, перевірку стекових змінних вимкнено, оскільки "
"у більшості програм стекові змінні не надаються у спільне користування "
"різним потокам виконання.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackVar)
#: tools/drd/drd_configpage.ui:84
#, kde-format
msgid "Detect data races on stack variables"
msgstr "Виявляти конкуренцію за дані для змінних зі стека"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:91
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report only the first data race that has "
"been detected on a memory location or all data races that have been detected "
"on a memory location.</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, слід звітувати лише про першу конкуренцію за "
"дані, яку було виявлено для місця у пам’яті, чи про усі конкуренції за дані, "
"які було виявлено для місця у пам’яті.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_firstRaceOnly)
#: tools/drd/drd_configpage.ui:94
#, kde-format
msgid "Report only the first data race"
msgstr "Звітувати лише про першу конкуренцію за дані"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:104
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report races between accessing memory and "
"freeing memory. Enabling this option may cause DRD to run slightly slower. "
"Notes:</p><p>Don't enable this option when using custom memory allocators "
"that use the <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">VG_USERREQ__MALLOCLIKE_BLOCK</span> and <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span> because that would result in false "
"positives. </p><p>Don't enable this option when using reference-counted "
"objects because that will result in false positives, even when that code has "
"been annotated properly with <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">ANNOTATE_HAPPENS_BEFORE</span> and <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_AFTER</span>. See e.g. the output of the following "
"command for an example: <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">valgrind --tool=drd --free-is-write=yes drd/"
"tests/annotate_smart_pointer</span>.</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи слід звітувати про конкуренцію між "
"доступом і вивільненням пам’яті. Вмикання такого звітування може трохи "
"сповільнити роботу DRD. Зауваження:</p><p>Не вмикайте звітування, якщо "
"використовуєте нетипові засоби отримання пам’яті, які використовують <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__MALLOCLIKE_BLOCK</span> і <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">VG_USERREQ__FREELIKE_BLOCK</span>, оскільки це призведе до помилок під "
"час виявлення вад.</p><p>Не використовуйте звітування, якщо використовуються "
"об’єкти із обчисленням кількості посилань, оскільки це призведе до помилок "
"під час обробки, навіть у коді, який належним чином анотовано за допомогою "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE</span> та <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER</span>. Див., "
"наприклад, виведення такої команди: <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">valgrind --tool=drd --free-is-"
"write=yes drd/tests/annotate_smart_pointer</span>.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/drd/drd_configpage.ui:107
#, kde-format
msgid "Report races between accessing and freeing memory"
msgstr "Звітувати про конкуренцію між доступом і вивільненням пам’яті"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>Whether to report calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_signal</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_broadcast</span> where "
"the mutex associated with the signal through <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">pthread_cond_wait</"
"span> or <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">pthread_cond_timed_wait</span> is not locked at the time the "
"signal is sent. Sending a signal without holding a lock on the associated "
"mutex is a common programming error which can cause subtle race conditions "
"and unpredictable behavior. There exist some uncommon synchronization "
"patterns however where it is safe to send a signal without holding a lock on "
"the associated mutex.</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи слід звітувати про виклики <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">pthread_cond_signal</span> та <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">pthread_cond_broadcast</span>, де "
"прапорець, який пов’язано із сигналом за допомогою <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">pthread_cond_wait</"
"span> або <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">pthread_cond_timed_wait</span>, не заблоковано на час "
"надсилання сигналу. Надсилання сигналу без утримання блокування на "
"пов’язаному прапорці є типовою помилкою програмування, яка може призводити "
"до майже непомітних конкуренцій та непередбачуваної поведінки. Втім, існують "
"деякі нетипові шаблони коду, у яких можна безпечно надсилати сигнал без "
"утримання блокування на пов’язаному прапорці.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_reportSignalUnlocked)
#: tools/drd/drd_configpage.ui:117
#, kde-format
msgid "Report calls to unlocked signals"
msgstr "Звітувати про виклики незаблокованих сигналів"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:124
#, kde-format
msgid ""
"<html><head/><body><p>Controls segment merging. Segment merging is an "
"algorithm to limit memory usage of the data race detection algorithm. "
"Disabling segment merging may improve the accuracy of the so-called 'other "
"segments' displayed in race reports but can also trigger an out of memory "
"error.</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує об’єднанням сегментів. Об’єднання сегментів є "
"алгоритмом, який обмежує споживання пам’яті алгоритмом виявлення конкуренції "
"за дані. Вимикання об’єднання сегментів може поліпшити точність показу так "
"званих «сторонніх сегментів» у звітах щодо конкуренції, але також може "
"призвести до помилок, які пов’язано із виходом за межі наданої області "
"пам’яті.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_segmentMerging)
#: tools/drd/drd_configpage.ui:127
#, kde-format
msgid "Segment merging"
msgstr "Об’єднання сегментів"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:134
#, kde-format
msgid ""
"<html><head/><body><p>Show conflicting segments in race reports. Since this "
"information can help to find the cause of a data race, this option is "
"enabled by default. Disabling this option makes the output of DRD more "
"compact.</p></body></html>"
msgstr ""
"<html><head/><body><p>Показувати конфліктні сегменти у звітах щодо "
"конкуренції. Оскільки ці дані можуть допомогти у виявленні причини "
"конкуренції за дані, цей параметр використовується типово. Вимикання цього "
"параметра може зробити дані, які буде виведено DRD, компактнішими.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showConflSeg)
#: tools/drd/drd_configpage.ui:137
#, kde-format
msgid "Show conflicting segments"
msgstr "Показати конфліктні сегменти"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:144
#, kde-format
msgid ""
"<html><head/><body><p>Print stack usage at thread exit time. When a program "
"creates a large number of threads it becomes important to limit the amount "
"of virtual memory allocated for thread stacks. This option makes it possible "
"to observe how much stack memory has been used by each thread of the client "
"program.</p><p>Note: the DRD tool itself allocates some temporary data on "
"the client thread stack. The space necessary for this temporary data must be "
"allocated by the client program when it allocates stack memory, but is not "
"included in stack usage reported by DRD.</p></body></html>"
msgstr ""
"<html><head/><body><p>Виводити дані щодо використання стека на час виходу із "
"потоку виконання. Якщо програма створює багато потоків, виникає потреба у "
"обмеженні об’єму віртуальної пам’яті, яка отримується для стеків потоків. За "
"допомогою цього параметрам можна спостерігати за тим, скільки пам’яті у "
"стеку було використано кожним потоком виконання клієнтської програми.</"
"p><p>Зауваження: засоби DRD самі розміщують частину тимчасових даних у стеку "
"клієнтського потоку виконання. Ділянку пам’яті, яка потрібна для цих "
"тимчасових даних, буде отримано клієнтською програмою, коли вона розміщує "
"дані у пам’яті стека, але не буде включено до звіту щодо використання стека "
"DRD.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showStackUsage)
#: tools/drd/drd_configpage.ui:147
#, kde-format
msgid "Show stack usage"
msgstr "Показати використання стека"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:154
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses DRD as "
"it assumes there is some false ordering in place between creator and created "
"thread; and therefore many types of race conditions in the application would "
"not be reported. To prevent such false ordering, this command line option is "
"set to <span style=\" font-family:'Monospace';\">yes</span> by default on "
"Solaris. All activity (loads, stores, client requests) is therefore ignored "
"during:</p><p>* pthread_create() call in the creator thread </p><p>* thread "
"creation phase (stack and TLS setup) in the created thread</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи слід ігнорувати усі дії під час "
"створення потоку виконання. Типово увімкнено лише у Solaris. У Solaris вищий "
"за інші системи рівень пропускної здатності, паралельності та "
"масштабованості. Це реалізовано за рахунок додаткових варіантів дій з "
"блокування. Це, наприклад, означає, що під час створення потоку у системі з "
"glibc, для налаштувань усіх потоків використовується одне велике блокування. "
"У Solaris з libc використовується декілька точніше регульованих блокувань, а "
"потік виконання, у якому відбувалося створення, відновлює свою роботу "
"якнайшвидше, лишаючи, наприклад, послідовність налаштовування стека і TLS "
"створеному потоку. Такі принципи роботи заважають DRD отримувати належні "
"дані, оскільки програма припускає, що між потоком створення і створеним "
"потоком виникло помилкове упорядковування; отже, програма не зможе "
"повідомити про багато типів помилок із конкуренцією у програмі. Щоб "
"запобігти такому помилковому упорядковуванню, типово у Solaris для цього "
"параметра встановлено значення <span style=\" font-family:'Monospace';"
"\">yes</span>. У такому режимі усі дії (завантаження, зберігання, запити "
"клієнтів) ігноруються під час таких подій:</p><p>* виклику pthread_create() "
"у потоці створення</p><p>* фази створення потоку (налаштування стека та TLS) "
"у створеному потоці</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/drd/drd_configpage.ui:157 tools/helgrind/helgrind_configpage.ui:105
#, kde-format
msgid "Ignore thread creation"
msgstr "Ігнорувати створення потоків"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showInstructionPointer)
#: tools/drd/drd_configpage.ui:171 tools/helgrind/helgrind_configpage.ui:132
#: tools/memcheck/memcheck_configpage.ui:210
#, kde-format
msgid "Show stack frame instruction pointer value"
msgstr "Показувати вказівник інструкцій стека кадрів"

#. i18n: ectx: attribute (title), widget (QWidget, tracesTab)
#: tools/drd/drd_configpage.ui:192
#, kde-format
msgid "Trace options"
msgstr "Параметри трасування"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:198
#, kde-format
msgid ""
"<html><head/><body><p>Trace all memory allocations and deallocations. May "
"produce a huge amount of output.</p></body></html>"
msgstr ""
"<html><head/><body><p>Трасувати усі розміщення у пам’яті і вивільнення "
"пам’яті. Може значно збільшити об’єм створених даних.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceAlloc)
#: tools/drd/drd_configpage.ui:201
#, kde-format
msgid "Trace memory allocations/deallocations"
msgstr "Трасувати отримання та вивільнення пам’яті"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:208
#, kde-format
msgid "<html><head/><body><p>Trace all barrier activity.</p></body></html>"
msgstr "<html><head/><body><p>Трасувати усі дії з бар’єрами.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceBarrier)
#: tools/drd/drd_configpage.ui:211
#, kde-format
msgid "Trace barrier activity"
msgstr "Трасувати дії з бар’єрами"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:218
#, kde-format
msgid ""
"<html><head/><body><p>Trace all condition variable activity.</p></body></"
"html>"
msgstr ""
"<html><head/><body><p>Трасувати усі дії з умовними змінними.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceCond)
#: tools/drd/drd_configpage.ui:221
#, kde-format
msgid "Trace condition variable activity"
msgstr "Трасувати дії з умовними змінними"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:228
#, kde-format
msgid ""
"<html><head/><body><p>Trace all thread creation and all thread termination "
"events.</p></body></html>"
msgstr ""
"<html><head/><body><p>Трасувати усі події зі створення та припинення роботи "
"потоків виконання.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceForkJoin)
#: tools/drd/drd_configpage.ui:231
#, kde-format
msgid "Trace thread creation/termination events"
msgstr "Трасувати події створення або переривання потоків"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:238
#, kde-format
msgid ""
"<html><head/><body><p>Trace execution of the <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE()</span>, <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER()</span> and "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span> client requests.</p></body></html>"
msgstr ""
"<html><head/><body><p>Трасувати виконання клієнтських запитів <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_BEFORE()</span>, <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">ANNOTATE_HAPPENS_AFTER()</span> та "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">ANNOTATE_HAPPENS_DONE()</span>.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceHb)
#: tools/drd/drd_configpage.ui:241
#, kde-format
msgid "Trace execution of \"ANNOTATE_HAPPENS\" requests"
msgstr "Трасувати виконання запитів «ANNOTATE_HAPPENS»"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:248
#, kde-format
msgid "<html><head/><body><p>Trace all mutex activity.</p></body></html>"
msgstr ""
"<html><head/><body><p>Трасувати усі дії з прапорцями.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceMutex)
#: tools/drd/drd_configpage.ui:251
#, kde-format
msgid "Trace mutex activity"
msgstr "Трасувати дії з прапорцями"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:258
#, kde-format
msgid ""
"<html><head/><body><p>Trace all reader-writer lock activity.</p></body></"
"html>"
msgstr ""
"<html><head/><body><p>Трасувати усі дії з блокуванням читання-запису.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceRwlock)
#: tools/drd/drd_configpage.ui:261
#, kde-format
msgid "Trace reader-writer lock activity"
msgstr "Трасувати дії з блокуванням читання-запису"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:268
#, kde-format
msgid "<html><head/><body><p>Trace all semaphore activity.</p></body></html>"
msgstr ""
"<html><head/><body><p>Трасувати усі дії з семафорами.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_traceSemaphore)
#: tools/drd/drd_configpage.ui:271
#, kde-format
msgid "Trace semaphore activity"
msgstr "Трасувати дії з семафорами"

#: tools/drd/drd_tool.cpp:35
#, kde-format
msgid "DRD"
msgstr "DRD"

#: tools/drd/drd_tool.cpp:36
#, kde-format
msgid "DRD (Thread Error Detector)"
msgstr "DRD (засіб виявлення помилок із потоками)"

#: tools/helgrind/helgrind_configpage.cpp:36
#, kde-format
msgid "Full"
msgstr "Повне"

#: tools/helgrind/helgrind_configpage.cpp:37
#, kde-format
msgid "Approx"
msgstr "Приблизно"

#: tools/helgrind/helgrind_configpage.cpp:38
#, kde-format
msgid "None"
msgstr "Відсутня"

#. i18n: ectx: property (text), widget (QLabel, historyLevelLabel)
#: tools/helgrind/helgrind_configpage.ui:22
#, kde-format
msgid "History level:"
msgstr "Рівень журналювання:"

#. i18n: ectx: property (text), widget (QLabel, conflictCacheSizeLabel)
#: tools/helgrind/helgrind_configpage.ui:29
#, kde-format
msgid "Conflict cache size:"
msgstr "Розмір кешу конфліктів:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_conflictCacheSize)
#: tools/helgrind/helgrind_configpage.ui:39
#, kde-format
msgid ""
"<html><head/><body><p>This flag only has any effect at <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
"level=full</span>.</p><p>Information about &quot;old&quot; conflicting "
"accesses is stored in a cache of limited size, with LRU-style management. "
"This is necessary because it isn't practical to store a stack trace for "
"every single memory access made by the program. Historical information on "
"not recently accessed locations is periodically discarded, to free up space "
"in the cache.</p><p>This option controls the size of the cache, in terms of "
"the number of different memory addresses for which conflicting access "
"information is stored. If you find that Helgrind is showing race errors with "
"only one stack instead of the expected two stacks, try increasing this value."
"</p><p>The minimum value is 10,000 and the maximum is 30,000,000 (thirty "
"times the default value). Increasing the value by 1 increases Helgrind's "
"memory requirement by very roughly 100 bytes, so the maximum value will "
"easily eat up three extra gigabytes or so of memory.</p></body></html>"
msgstr ""
"<html><head/><body><p>Цей прапорець працюватиме, лише якщо вказано параметр "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--history-level=full</span>.</p><p>Інформація щодо «застарілих» "
"конфліктних доступах зберігається у кеші обмеженого розміру із поступовим "
"вилученням застарілих записів. Так зроблено, оскільки непрактично зберігати "
"трасування стека для кожного доступу до пам’яті з боку програми. Застарілі "
"дані щодо давніх доступів періодично відкидаються для вивільнення місця у "
"кеші.</p><p>За допомогою цього параметра можна керувати розміром кешу, "
"вказуючи кількість різних адрес у пам’яті, для яких слід зберігати дані щодо "
"конфліктів доступу. Якщо вами буде виявлено, що Helgrind показує помилки "
"лише з одним стеком замість очікуваних двох, спробуйте збільшити це значення."
"</p><p>Мінімальним є значення у 10000, а максимальним — у 30000000 "
"(утридцятеро більше за типове значення). Збільшення значення на 1 збільшує "
"використання Helgrind пам’яті на приблизно 100 байтів, отже за максимального "
"значення буде спожито додатково приблизно 3 гігабайти пам’яті.</p></body></"
"html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:78
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (the default), Helgrind performs lock "
"order consistency checking. For some buggy programs, the large number of "
"lock order errors reported can become annoying, particularly if you're only "
"interested in race errors. You may therefore find it helpful to disable lock "
"order checking.</p></body></html>"
msgstr ""
"<html><head/><body><p>Якщо позначено (типова поведінка), Helgrind "
"виконуватиме перевірку послідовності порядку блокування. У деяких програмах "
"із вадами велика кількість помилок порядку блокування у звіті може бути "
"доволі набридливою, зокрема, якщо ви цікавитеся лише конфліктами доступу. "
"Тому, може виникнути потреба у вимиканні перевірки порядку блокування.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackLockorders)
#: tools/helgrind/helgrind_configpage.ui:81
#, kde-format
msgid "Track lock orders"
msgstr "Стежити за порядком блокування"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:92
#, kde-format
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">By default Helgrind checks "
"all data memory accesses made by your program. This flag enables you to skip "
"checking for accesses to thread stacks (local variables). This can improve "
"performance, but comes at the cost of missing races on stack-allocated data."
"</p></body></html>"
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
"REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css"
"\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:'Sans Serif'; font-size:14pt; font-"
"weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
"right:0px; -qt-block-indent:0; text-indent:0px;\">Типово Helgrind перевіряє "
"усі спроби доступу до пам’яті, які виконуються програмою. За допомогою цього "
"прапорця ви можете пропустити перевірку доступів до стеків потоків "
"(локальних змінних). Це може поліпшити швидкодію, але при цьому буде "
"пропущено конфлікти у розміщенні даних у стеку.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_checkStackRefs)
#: tools/helgrind/helgrind_configpage.ui:95
#, kde-format
msgid "Check stack refs"
msgstr "Перевіряти посилання у стеку"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_ignoreThreadCreation)
#: tools/helgrind/helgrind_configpage.ui:102
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether all activities during thread creation "
"should be ignored. By default enabled only on Solaris. Solaris provides "
"higher throughput, parallelism and scalability than other operating systems, "
"at the cost of more fine-grained locking activity. This means for example "
"that when a thread is created under glibc, just one big lock is used for all "
"thread setup. Solaris libc uses several fine-grained locks and the creator "
"thread resumes its activities as soon as possible, leaving for example stack "
"and TLS setup sequence to the created thread. This situation confuses "
"Helgrind as it assumes there is some false ordering in place between creator "
"and created thread; and therefore many types of race conditions in the "
"application would not be reported. To prevent such false ordering, this "
"command line option is set to yes by default on Solaris. All activity "
"(loads, stores, client requests) is therefore ignored during:</p><p>* "
"pthread_create() call in the creator thread</p><p>* thread creation phase "
"(stack and TLS setup) in the created thread</p><p>Also new memory allocated "
"during thread creation is untracked, that is race reporting is suppressed "
"there. DRD does the same thing implicitly. This is necessary because Solaris "
"libc caches many objects and reuses them for different threads and that "
"confuses Helgrind.</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи слід ігнорувати усі дії під час "
"створення потоку виконання. Типово увімкнено лише у Solaris. У Solaris вищий "
"за інші системи рівень пропускної здатності, паралельності та "
"масштабованості. Це реалізовано за рахунок додаткових варіантів дій з "
"блокування. Це, наприклад, означає, що під час створення потоку у системі з "
"glibc, для налаштувань усіх потоків використовується одне велике блокування. "
"У Solaris з libc використовується декілька точніше регульованих блокувань, а "
"потік виконання, у якому відбувалося створення, відновлює свою роботу "
"якнайшвидше, лишаючи, наприклад, послідовність налаштовування стека і TLS "
"створеному потоку. Такі принципи роботи заважають Helgrind отримувати "
"належні дані, оскільки програма припускає, що між потоком створення і "
"створеним потоком виникло помилкове упорядковування; отже, програма не зможе "
"повідомити про багато типів помилок із конкуренцією у програмі. Щоб "
"запобігти такому помилковому упорядковуванню, типово у Solaris для цього "
"параметра встановлено значення «yes». У такому режимі усі дії (завантаження, "
"зберігання, запити клієнтів) ігноруються під час таких подій:</p><p>* "
"виклику pthread_create() у потоці створення</p><p>* фази створення потоку "
"(налаштування стека та TLS) у створеному потоці</p><p>Крім того, не "
"відбувається стеження на розміщеннями у пам’яті, які було виконано під час "
"створення потоку, тобто виконується придушення звітування про конкуренцію у "
"цих областях пам’яті. DRD дає те саме, але неявно. Це необхідно, оскільки "
"libc у Solaris кешує багато об’єктів і повторно використовує їх для різних "
"потоків, що збиває Helgrind з пантелику.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:115
#, kde-format
msgid ""
"<html><head/><body><p>When enabled (not the default), Helgrind treats "
"freeing of heap memory as if the memory was written immediately before the "
"free. This exposes races where memory is referenced by one thread, and freed "
"by another, but there is no observable synchronization event to ensure that "
"the reference happens before the free.</p><p>This functionality is new in "
"Valgrind 3.7.0, and is regarded as experimental. It is not enabled by "
"default because its interaction with custom memory allocators is not well "
"understood at present. User feedback is welcomed.</p></body></html>"
msgstr ""
"<html><head/><body><p>Якщо увімкнено (нетипова поведінка), Helgrind "
"вважатиме, що безпосередньо перед вивільненням пам’яті «купи» до неї було "
"виконано запис. Це надасть змогу виявити ситуації, коли на пам’ять посилався "
"один потік виконання, а вивільнено пам’ять було у іншому потоці без видимої "
"події синхронізації для забезпечення належного порядку: спочатку посилання, "
"потім вивільнення.</p><p>Ця можливість є новою у Valgrind 3.7.0, вона "
"вважається експериментальною. Типово її не увімкнено, оскільки її взаємодію "
"із нетиповими засобами розміщення у пам’яті ще недостатньо вивчено. "
"Розробники будуть раді відгукам користувачів.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_freeIsWrite)
#: tools/helgrind/helgrind_configpage.ui:118
#, kde-format
msgid "Free is write (experimental)"
msgstr "Вивільнення є записом (експериментальне)"

#: tools/helgrind/helgrind_tool.cpp:35
#, kde-format
msgid "Helgrind"
msgstr "Helgrind"

#: tools/helgrind/helgrind_tool.cpp:36
#, kde-format
msgid "Helgrind (Thread Error Detector)"
msgstr "Helgrind (засіб виявлення помилок із потоками)"

#: tools/massif/massif_configpage.cpp:39
#, kde-format
msgid "CPU instructions"
msgstr "Команди процесора"

#: tools/massif/massif_configpage.cpp:40
#, kde-format
msgid "Milliseconds"
msgstr "мілісекунди"

#: tools/massif/massif_configpage.cpp:41
#, kde-format
msgid "Bytes allocated"
msgstr "Виділені байти"

#. i18n: ectx: property (text), widget (QLabel, timeUnitLabel)
#: tools/massif/massif_configpage.ui:25
#, kde-format
msgid "Time unit:"
msgstr "Одиниця часу:"

#. i18n: ectx: property (text), widget (QLabel, snapshotTreeDepthLabel)
#: tools/massif/massif_configpage.ui:32
#, kde-format
msgid "Snapshot tree depth:"
msgstr "Глибина ієрархії знімка:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_snapshotTreeDepth)
#: tools/massif/massif_configpage.ui:42
#, kde-format
msgid ""
"<html><head/><body><p>Maximum depth of the allocation trees recorded for "
"detailed snapshots. Increasing it will make Massif run somewhat more slowly, "
"use more memory, and produce bigger output files.</p></body></html>"
msgstr ""
"<html><head/><body><p>Максимальна глибина ієрархій розміщення даних, які "
"записано для докладних знімків. Збільшення цього значення дещо уповільнить "
"Massif та збільшить споживання пам’яті, а також призведе до зростання об’єму "
"створених програмою файлів.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, thresholdLabel)
#: tools/massif/massif_configpage.ui:49
#, kde-format
msgid "Threshold:"
msgstr "Поріг:"

#. i18n: ectx: property (text), widget (QLabel, peakInaccuracyLabel)
#: tools/massif/massif_configpage.ui:59
#, kde-format
msgid "Peak inaccuracy:"
msgstr "Похибка піків:"

#. i18n: ectx: property (text), widget (QLabel, maximumSnapshotsLabel)
#: tools/massif/massif_configpage.ui:69
#, kde-format
msgid "Maximum snapshots:"
msgstr "Макс. к-ть знімків:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_maximumSnapshots)
#: tools/massif/massif_configpage.ui:79
#, kde-format
msgid ""
"<html><head/><body><p>The maximum number of snapshots recorded. If set to N, "
"for all programs except very short-running ones, the final number of "
"snapshots will be between N/2 and N.</p></body></html>"
msgstr ""
"<html><head/><body><p>Максимальна кількість записаних знімків. Якщо "
"встановити значення N, для усіх програм, окрім тих, які виконуються дуже "
"швидко, остаточна кількість знімків коливатиметься від N/2 до N.</p></body></"
"html>"

#. i18n: ectx: property (text), widget (QLabel, detailedSnapshotsFrequencyLabel)
#: tools/massif/massif_configpage.ui:86
#, kde-format
msgid "Detailed snapshot frequency:"
msgstr "Частота докладних знімків:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_detailedSnapshotsFrequency)
#: tools/massif/massif_configpage.ui:96
#, kde-format
msgid ""
"<html><head/><body><p>Frequency of detailed snapshots. With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--detailed-"
"freq=1</span>, every snapshot is detailed.</p></body></html>"
msgstr ""
"<html><head/><body><p>Частота створення докладних знімків. Якщо вказано "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--detailed-freq=1</span>, усі знімки будуть докладними.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, extraArgsLabel)
#: tools/massif/massif_configpage.ui:103
#: tools/memcheck/memcheck_configpage.ui:121
#, kde-format
msgid "E&xtra parameters:"
msgstr "Додаткові &параметри:"

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_threshold)
#: tools/massif/massif_configpage.ui:123
#, kde-format
msgid ""
"<html><head/><body><p>The significance threshold for heap allocations, as a "
"percentage of total memory size. Allocation tree entries that account for "
"less than this will be aggregated. Note that this should be specified in "
"tandem with ms_print's option of the same name.</p></body></html>"
msgstr ""
"<html><head/><body><p>Порогова значимість для розміщень у «купі» у відсотках "
"щодо загального об’єму пам’яті. Записи ієрархії розміщення даних, які "
"матимуть менше значення, будуть об’єднуватися. Зауважте, що цей параметр "
"слід поєднуватися із параметром ms_print із тією ж назвою.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QDoubleSpinBox, kcfg_peakInaccuracy)
#: tools/massif/massif_configpage.ui:136
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Massif does not necessarily record the actual global "
"memory allocation peak; by default it records a peak only when the global "
"memory allocation size exceeds the previous peak by at least 1.0%. This is "
"because there can be many local allocation peaks along the way, and doing a "
"detailed snapshot for every one would be expensive and wasteful, as all but "
"one of them will be later discarded. This inaccuracy can be changed (even to "
"0.0%) via this option, but Massif will run drastically slower as the number "
"approaches zero.</p></body></html>"
msgstr ""
"<html><head/><body><p>Massif не обов’язково записує справжнє пікове значення "
"отримання пам’яті. Типово, програма записує пік, лише якщо загалом об’єм "
"отриманої пам’яті перевищує попереднє пікове значення принаймні на 1 %. Так "
"зроблено, оскільки під час роботи може бути багато локальних пікових "
"значень, а створення докладного знімка для кожного з таких значень є справою "
"витратною і марною, оскільки усі ці дані буде потім відкинуто. За допомогою "
"цього параметра ви можете змінити цей крок зміни пікового значення (навіть "
"визначити його рівним 0 %), але при цьому Massif працюватиме усе повільніше "
"із наближенням цього значення до нуля.</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:158
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether heap profiling should be done.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи слід виконувати профілювання «купи».</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileHeap)
#: tools/massif/massif_configpage.ui:161
#, kde-format
msgid "Profile heap"
msgstr "Профілювати динамічну пам’ять"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:171
#, kde-format
msgid ""
"<html><head/><body><p>Specifies whether stack profiling should be done. This "
"option slows Massif down greatly, and so is off by default. Note that Massif "
"assumes that the main stack has size zero at start-up. This is not true, but "
"doing otherwise accurately is difficult. Furthermore, starting at zero "
"better indicates the size of the part of the main stack that a user program "
"actually has control over.</p></body></html>"
msgstr ""
"<html><head/><body><p>Визначає, чи слід виконувати профілювання стека. "
"Використання цього параметра значно уповільнює роботу Massif, тому типового "
"його вимкнено. Зауважте, що Massif припускає, що одразу після запуску "
"головний стек має нульовий розмір. На практиці, такого не буває, але точно "
"визначити справжній розмір стека важко. Крім того, нульове значення краще "
"свідчить про розмір частини основного стека, який насправді контролює "
"запущена користувачем програма.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_profileStack)
#: tools/massif/massif_configpage.ui:174
#, kde-format
msgid "Profile stack (slows profiling down greatly)"
msgstr "Профілювати стек (значно сповільнює профілювання)"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:181
#, kde-format
msgid ""
"<html><head/><body><p>Tells Massif to profile memory at the page level "
"rather than at the malloc'd block level.</p></body></html>"
msgstr ""
"<html><head/><body><p>Повідомляє Massif, що слід профілювати пам’ять на "
"рівні сторінок, а не на рівні блоків, які отримано за допомогою malloc.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_pagesAsHeap)
#: tools/massif/massif_configpage.ui:184
#, kde-format
msgid "Pages as heap"
msgstr "Сторінки як «купа»"

#. i18n: ectx: property (text), widget (KMessageWidget, messageWidget)
#: tools/massif/massif_configpage.ui:191
#, kde-format
msgid ""
"<html><head/><body><p>&quot;Pages as heap&quot; cannot be used together with "
"&quot;Profile stack&quot;.</p></body></html>"
msgstr ""
"<html><head/><body><p>«Сторінки як «купа»» не можна використовувати разом із "
"«Профілювати стек».</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_launchVisualizer)
#: tools/massif/massif_configpage.ui:214
#, kde-format
msgid "Launch Massif Visualizer after analysis finish"
msgstr "Запустити візуалізатор Massif після завершення аналізу"

#: tools/massif/massif_model.cpp:126
#, kde-format
msgid "Snapshot"
msgstr "Знімок"

#: tools/massif/massif_model.cpp:129
#, kde-format
msgid "Time"
msgstr "Час"

#: tools/massif/massif_model.cpp:132
#, kde-format
msgid "Heap"
msgstr "Купа"

#: tools/massif/massif_model.cpp:135
#, kde-format
msgid "Heap (extra)"
msgstr "Купа (додаткова)"

#: tools/massif/massif_model.cpp:138
#, kde-format
msgid "Stack"
msgstr "Стек"

#: tools/massif/massif_tool.cpp:35
#, kde-format
msgid "Massif"
msgstr "Massif"

#: tools/massif/massif_tool.cpp:36
#, kde-format
msgid "Massif (Heap Profiler)"
msgstr "Massif (засіб профілювання «купи»)"

#. i18n: ectx: property (text), widget (QLabel, snapshotsLabel)
#: tools/massif/massif_view.ui:36
#, kde-format
msgid "Snapshots"
msgstr "Знімки"

#. i18n: ectx: property (text), widget (QLabel, treesLabel)
#: tools/massif/massif_view.ui:56
#, kde-format
msgid "Heap trees"
msgstr "Дерева купи даних"

#. i18n: ectx: property (text), widget (QPushButton, launchVisualizerButton)
#: tools/massif/massif_view.ui:70
#, kde-format
msgid "Launch visualizer"
msgstr "Запустити візуалізатор"

#: tools/memcheck/memcheck_configpage.cpp:43
#, kde-format
msgid "definite"
msgstr "визначений"

#: tools/memcheck/memcheck_configpage.cpp:44
#, kde-format
msgid "possible"
msgstr "можливий"

#: tools/memcheck/memcheck_configpage.cpp:45
#, kde-format
msgid "indirect"
msgstr "опосередкований"

#: tools/memcheck/memcheck_configpage.cpp:46
#, kde-format
msgid "reachable"
msgstr "досяжний"

#. i18n text ?
#: tools/memcheck/memcheck_configpage.cpp:50
#, kde-format
msgid "stdstring"
msgstr "стандартний рядок"

#: tools/memcheck/memcheck_configpage.cpp:51
#, kde-format
msgid "length64"
msgstr "довжина64"

#: tools/memcheck/memcheck_configpage.cpp:52
#, kde-format
msgid "newarray"
msgstr "новий масив"

#: tools/memcheck/memcheck_configpage.cpp:53
#, kde-format
msgid "multipleinheritance"
msgstr "кратне успадковування"

#: tools/memcheck/memcheck_configpage.cpp:56
#, kde-format
msgid "high"
msgstr "високий"

#: tools/memcheck/memcheck_configpage.cpp:57
#, kde-format
msgid "medium"
msgstr "середній"

#: tools/memcheck/memcheck_configpage.cpp:58
#, kde-format
msgid "low"
msgstr "низький"

#: tools/memcheck/memcheck_configpage.cpp:60
#, kde-format
msgid "alloc"
msgstr "alloc"

#: tools/memcheck/memcheck_configpage.cpp:61
#, kde-format
msgid "free"
msgstr "free"

#: tools/memcheck/memcheck_configpage.cpp:62
#, kde-format
msgid "alloc-and-free"
msgstr "alloc-and-free"

#: tools/memcheck/memcheck_configpage.cpp:63
#, kde-format
msgid "alloc-then-free"
msgstr "alloc-then-free"

#. i18n: ectx: property (text), widget (QLabel, leakResolutionLabel)
#: tools/memcheck/memcheck_configpage.ui:25
#, kde-format
msgid "Leak resolution:"
msgstr "Розв’язування витоків:"

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_leakResolution)
#: tools/memcheck/memcheck_configpage.ui:32
#, kde-format
msgid ""
"<html><head/><body><p>When doing leak checking, determines how willing "
"Memcheck is to consider different backtraces to be the same for the purposes "
"of merging multiple leaks into a single leak report. When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">low</"
"span>, only the first two entries need match. When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">med</span>, four "
"entries have to match. When <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">high</span>, all entries need to match.</"
"p><p>For hardcore leak debugging, you probably want to use <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> together with <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--num-callers=40</span> or some such "
"large number.</p><p>Note that the <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--leak-resolution</span> setting does "
"not affect Memcheck's ability to find leaks. It only changes how the results "
"are presented.</p></body></html>"
msgstr ""
"<html><head/><body><p>Під час перевірки на витоки визначає, наскільки "
"Memcheck вважатиме інші зворотні трасування подібними для об’єднання "
"декількох витоків у один звіт щодо витоку. Якщо встановлено значення <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">low</"
"span>, мають збігатися перші два записи. Якщо встановлено значення <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">med</"
"span>, мають збігатися перші чотири записи. Якщо встановлено значення <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">high</span>, мають збігатися усі записи.</p><p>Якщо потрібен доскіпливий "
"пошук витоків, варто скористатися параметром <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--leak-"
"resolution=high</span> у поєднанні з <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--num-callers=40</span> або якимось "
"іншим достатньо великим числом для num-callers.</p><p>Зауважте, що "
"встановлення параметра <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--leak-resolution</span> не вплине на "
"можливість пошуку витоків за допомогою Memcheck. Цей параметр змінить лише "
"спосіб представлення результатів.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, showLeakKindsLabel)
#: tools/memcheck/memcheck_configpage.ui:39
#, kde-format
msgid "Show leak kinds:"
msgstr "Показувати такі типи витоків:"

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_showLeakKinds)
#: tools/memcheck/memcheck_configpage.ui:46
#, kde-format
msgid "Specifies the leak kinds to show."
msgstr "Визначає типи витоків, які слід показувати."

#. i18n: ectx: property (text), widget (QLabel, leakCheckHeuristicsLabel)
#: tools/memcheck/memcheck_configpage.ui:59
#, kde-format
msgid "Used heuristics:"
msgstr "Використана евристика:"

#. i18n: ectx: property (toolTip), widget (MenuButton, kcfg_leakCheckHeuristics)
#: tools/memcheck/memcheck_configpage.ui:66
#, kde-format
msgid ""
"<html><head/><body><p>Specifies the set of leak check heuristics to be used "
"during leak searches. The heuristics control which interior pointers to a "
"block cause it to be considered as reachable.</p></body></html>"
msgstr ""
"<html><head/><body><p>Вказує набір евристики для пошуку витоків. Евристика "
"керує тим, які внутрішні вказівники на блоки вважатимуться досяжними.</p></"
"body></html>"

#. i18n: ectx: property (text), widget (QLabel, keepStacktracesLabel)
#: tools/memcheck/memcheck_configpage.ui:76
#, kde-format
msgid "Stacktraces keeping:"
msgstr "Зберігання трасувань стека:"

#. i18n: ectx: property (toolTip), widget (Valgrind::ComboBox, kcfg_keepStacktraces)
#: tools/memcheck/memcheck_configpage.ui:83
#, kde-format
msgid ""
"<html><head/><body><p>Controls which stack trace(s) to keep for malloc'd and/"
"or free'd blocks. </p><p>With <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, a stack trace is "
"recorded at allocation time, and is associated with the block. When the "
"block is freed, a second stack trace is recorded, and this replaces the "
"allocation stack trace. As a result, any &quot;use after free&quot; errors "
"relating to this block can only show a stack trace for where the block was "
"freed. </p><p>With <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">alloc-and-free</span>, both allocation and the "
"deallocation stack traces for the block are stored. Hence a &quot;use after "
"free&quot; error will show both, which may make the error easier to "
"diagnose. Compared to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">alloc-then-free</span>, this setting "
"slightly increases Valgrind's memory use as the block contains two "
"references instead of one. </p><p>With <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc</span>, only "
"the allocation stack trace is recorded (and reported). With <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, "
"only the deallocation stack trace is recorded (and reported). These values "
"somewhat decrease Valgrind's memory and cpu usage. They can be useful "
"depending on the error types you are searching for and the level of detail "
"you need to analyze them. For example, if you are only interested in memory "
"leak errors, it is sufficient to record the allocation stack traces. </"
"p><p>With <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">none</span>, no stack traces are recorded for malloc and "
"free operations. If your program allocates a lot of blocks and/or allocates/"
"frees from many different stack traces, this can significantly decrease cpu "
"and/or memory required. Of course, few details will be reported for errors "
"related to heap blocks. </p><p>Note that once a stack trace is recorded, "
"Valgrind keeps the stack trace in memory even if it is not referenced by any "
"block. Some programs (for example, recursive algorithms) can generate a huge "
"number of stack traces. If Valgrind uses too much memory in such "
"circumstances, you can reduce the memory required with the options <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"keep-stacktraces</span> and/or by using a smaller value for the option <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"num-callers</span>. </p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, які трасування стека слід зберігати для "
"блоків, отриманих malloc і/або звільнених free.</p><p>Якщо вказано <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">alloc-then-free</span>, трасування стека записуватиметься на момент "
"розміщення даних у пам’яті і буде пов’язано із блоком. Коли блок "
"звільнятиметься, записуватиметься інше трасування стека, яким "
"замінюватиметься трасування стека на час розміщення даних. У результаті для "
"будь-яких помилок «використання після вивільнення», пов’язаних із цим "
"блоком, може бути показано лише трасування стека там, де блок було звільнено."
"</p><p>Якщо вказано <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">alloc-and-free</span>, зберігатимуться трасування стека "
"для розміщення даних у пам’яті і для вивільнення місця у пам’яті. Отже, для "
"помилки «використання після вивільнення» буде показано обидва стека, що може "
"полегшити визначення причини помилки. Порівняно з <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">alloc-then-free</"
"span>, у цьому варіанті дещо зростає вживання пам’яті Valgrind, оскільки "
"блок міститиме два посилання замість одного.</p><p>Якщо вказано <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">alloc</"
"span>, записуватиметься (і включатиметься до звіту) лише стек на момент "
"розміщення даних у пам’яті. Якщо вказано <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, "
"записуватиметься (і включатиметься до звіту) лише стек на момент вивільнення "
"пам’яті. Ці значення дещо зменшують вживання пам’яті і потужності процесора "
"Valgrind. Вони можуть бути корисним, якщо ви шукаєте помилки певного типу "
"або потребуєте певного рівня деталізації для аналізу помилок. Наприклад, "
"якщо ви вивчаєте лише помилки, які пов’язано із витоками пам’яті, достатньо "
"записувати трасування стека на час розміщення даних.</p><p>Якщо вказано "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">none</span>, трасування стека для дій malloc і free не записуватимуться. "
"Якщо у вашій програмі розміщується багато блоків даних і/або розміщуються "
"дані або вивільняється пам’ять з багатьох різних трасувань стека, це може "
"значно зменшити вживання потужностей процесора і/або пам’яті. Звичайно ж, до "
"звіту буде включено певні подробиці для помилок, які пов’язано із блоками "
"«купи».</p><p>Зауважте, що після записування трасування стека, Valgrind "
"зберігає трасування стека у пам’яті, навіть якщо на нього не посилається "
"жоден блок. Деякі програми (наприклад програми з рекурсивними алгоритмами "
"роботи) можуть призводити до створення величезної кількості трасувань стека. "
"Якщо Valgrind за таких обставин вживає надто багато пам’яті, ви можете "
"зменшити споживання за допомогою параметрів <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--keep-"
"stacktraces</span> і/або менших значень для параметра <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--num-callers</"
"span>.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, freelistVolLabel)
#: tools/memcheck/memcheck_configpage.ui:90
#, kde-format
msgid "Freelist maximum size:"
msgstr "Максимальний розмір списку вільних блоків:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistVol)
#: tools/memcheck/memcheck_configpage.ui:100
#, kde-format
msgid ""
"<html><head/><body><p>When the client program releases memory using <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">free</span> (in <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">C</span>) or <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">delete</span> (<span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">C++</span>), that "
"memory is not immediately made available for re-allocation. Instead, it is "
"marked inaccessible and placed in a queue of freed blocks. The purpose is to "
"defer as long as possible the point at which freed-up memory comes back into "
"circulation. This increases the chance that Memcheck will be able to detect "
"invalid accesses to blocks for some significant period of time after they "
"have been freed.</p><p>This option specifies the maximum total size, in "
"bytes, of the blocks in the queue. The default value is twenty million "
"bytes. Increasing this increases the total amount of memory used by Memcheck "
"but may detect invalid uses of freed blocks which would otherwise go "
"undetected.</p></body></html>"
msgstr ""
"<html><head/><body><p>Коли клієнтська програма вивільняє пам’ять за "
"допомогою <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">free</span> (у <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">C</span>) або <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span> (у "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">C++</span>), ця пам’ять не одразу стає знову придатною для розміщення у "
"ній даних. Замість цього, система позначає її як недоступну і розміщує у "
"черзі звільнених блоків. Метою є якомога більше віддалення моменту, коли "
"вивільнена пам’ять знову надходить у обіг. Це збільшує ймовірність того, що "
"Memcheck вдасться виявити некоректні доступу до блоків за певний час після "
"їхнього вивільнення.</p><p>За допомогою цього параметра визначається "
"максимальний загальний об’єм, у байтах, блоків у черзі. Типовим є значення у "
"двадцять мільйонів байтів. Збільшення цього значення збільшує загальний "
"об’єм пам’яті, що використовується Memcheck, але надає змогу виявити "
"некоректне використання вивільнених блоків, яке за інших обставин залишилося "
"непоміченим.</p></body></html>"

#. i18n: ectx: property (text), widget (QLabel, freelistBigBlocksLabel)
#: tools/memcheck/memcheck_configpage.ui:107
#, kde-format
msgid "Freelist big-blocks:"
msgstr "Великі блоки списку вільних блоків:"

#. i18n: ectx: property (toolTip), widget (QSpinBox, kcfg_freelistBigBlocks)
#: tools/memcheck/memcheck_configpage.ui:114
#, kde-format
msgid ""
"<html><head/><body><p>When making blocks from the queue of freed blocks "
"available for re-allocation, Memcheck will in priority re-circulate the "
"blocks with a size greater or equal to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--freelist-big-"
"blocks</span>. This ensures that freeing big blocks (in particular freeing "
"blocks bigger than <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">--freelist-vol</span>) does not immediately lead to a "
"re-circulation of all (or a lot of) the small blocks in the free list. In "
"other words, this option increases the likelihood to discover dangling "
"pointers for the &quot;small&quot; blocks, even when big blocks are freed.</"
"p><p>Setting a value of 0 means that all the blocks are re-circulated in a "
"FIFO order.</p></body></html>"
msgstr ""
"<html><head/><body><p>Роблячи блоки з черги вивільнених блоків доступними "
"для повторного розміщення даних, Memcheck за пріоритетністю повертає до "
"обігу блоки з розміром, який рівний або перевищує значення параметра <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"freelist-big-blocks</span>. Таким чином забезпечується те, що вивільнення "
"великих блоків (зокрема вивільнення блоків, розмір яких перевищує значення "
"параметра <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">--freelist-vol</span>) не призводить до негайного повернення "
"до обігу усіх (або більшості) малих блоків у списку вивільнення. Іншими "
"словами, цей параметр збільшує ймовірність виявлення «завислих» вказівників "
"на «малі» блоки, навіть коли вивільняються великі блоки.</p><p>Встановлення "
"значення 0 для цього параметра означатиме, що усі блоки повертатимуться до "
"обігу у порядку «перший надійшов — перший вивільниться».</p></body></html>"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:150
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck reports uses of undefined "
"value errors. Set this to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">no</span> if you don't want to see "
"undefined value errors. It also has the side effect of speeding up Memcheck "
"somewhat.</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи слід Memcheck звітувати про помилки, які "
"пов’язано із використанням невизначених значень. Встановіть значення <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">no</"
"span>, якщо вам непотрібні повідомлення щодо таких помилок. Побіжним ефектом "
"вимикання цих помилок є певне пришвидшення роботи Memcheck.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_undefValueErrors)
#: tools/memcheck/memcheck_configpage.ui:153
#, kde-format
msgid "Show undefined values usage"
msgstr "Показувати використання невизначних значень"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:163
#, kde-format
msgid ""
"<html><head/><body><p>When enabled, Memcheck checks that heap blocks are "
"deallocated using a function that matches the allocating function. That is, "
"it expects <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">free</span> to be used to deallocate blocks allocated by "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">malloc</span>, <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">delete</span> for blocks allocated by <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>, "
"and <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">delete[]</span> for blocks allocated by <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span>. If a "
"mismatch is detected, an error is reported. This is in general important "
"because in some environments, freeing with a non-matching function can cause "
"crashes.</p><p>There is however a scenario where such mismatches cannot be "
"avoided. That is when the user provides implementations of <span style=\" "
"font-family:'Monospace'; font-weight:600; font-style:italic;\">new</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">new[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">malloc</span> and of <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> that call <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">free</span>, and these functions are "
"asymmetrically inlined. For example, imagine that <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span> is "
"inlined but <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">new[]</span> is not. The result is that Memcheck &quot;"
"sees&quot; all <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">delete[]</span> calls as direct calls to <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, even "
"when the program source contains no mismatched calls.</p><p>This causes a "
"lot of confusing and irrelevant error reports. <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--show-mismatched-"
"frees=no</span> disables these checks. It is not generally advisable to "
"disable them, though, because you may miss real errors as a result.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>Якщо увімкнено, Memcheck перевірятиме, чи "
"вивільняються блоки «купи» за допомогою функції, яка відповідає функції "
"розміщення блоків. Тобто, програма перевірятиме, чи використано <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">free</"
"span> для вивільнення блоків, які було отримано для розміщення даних за "
"допомогою функції <span style=\" font-family:'Monospace'; font-weight:600; "
"font-style:italic;\">malloc</span>, чи використано <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span> для "
"блоків, які отримано за допомогою <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">new</span>, і чи використано <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span> для блоків, які отримано за допомогою <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new[]</span>. Якщо "
"буде виявлено невідповідність, програма повідомить про помилку. Це загалом "
"важливо, оскільки у певних середовищах вивільнення за допомогою "
"невідповідної функції може призвести до аварійних завершень роботи програми."
"</p><p>Втім, існують сценарії, за яких таких невідповідностей не уникнути. "
"Таке трапляється, якщо користувач надає реалізації <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">new</span>/<span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">new[]</span>, які викликають <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">malloc</span>, і <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete</span>/"
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">delete[]</span>, які викликають <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">free</span>, і ці функції є "
"асиметрично вбудованими. Наприклад, припустімо, що <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">delete[]</span> "
"вбудовано, а <span style=\" font-family:'Monospace'; font-weight:600; font-"
"style:italic;\">new[]</span> — ні. У результаті Memcheck «бачить» усі "
"виклики <span style=\" font-family:'Monospace'; font-weight:600; font-style:"
"italic;\">delete[]</span> як безпосередні виклики <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">free</span>, "
"навіть якщо у коді програми немає викликів без відповідників.</p><p>Це "
"спричиняє багато незрозумілих та помилкових звітів щодо помилок. Параметр "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--show-mismatched-frees=no</span> вимикає такі перевірки. Загалом, ми не "
"радимо вимикати ці перевірки, оскільки ви можете пропустити якісь справжні "
"помилки.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_showMismatchedFrees)
#: tools/memcheck/memcheck_configpage.ui:166
#, kde-format
msgid "Show mismatched frees"
msgstr "Показувати невідповідні звільнення"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:173
#, kde-format
msgid ""
"<html><head/><body><p>Controls how Memcheck handles 32-, 64-, 128- and 256-"
"bit naturally aligned loads from addresses for which some bytes are "
"addressable and others are not. When <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">yes</span>, such loads do not produce "
"an address error. Instead, loaded bytes originating from illegal addresses "
"are marked as uninitialised, and those corresponding to legal addresses are "
"handled in the normal way.</p><p>When <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">no</span>, loads "
"from partially invalid addresses are treated the same as loads from "
"completely invalid addresses: an illegal-address error is issued, and the "
"resulting bytes are marked as initialised.</p><p>Note that code that behaves "
"in this way is in violation of the ISO C/C++ standards, and should be "
"considered broken. If at all possible, such code should be fixed.</p></"
"body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, як Memcheck обробляє 32-, 64-, 128- іd 256-"
"бітові природно вирівняні завантаження з адрес, для яких частина байтів є "
"адресованою, а частина — ні. Якщо встановлено значення <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">yes</span>, такі "
"завантаження не призводитимуть до повідомлення про помилки адресування. "
"Замість цього, завантажені байти, які походять з некоректних адрес, "
"позначатимуться як неініціалізовані, а ті, які походять з коректних адрес, "
"оброблятимуться у звичайний спосіб.</p><p>Якщо встановлено значення <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">no</"
"span>, завантаження з частково некоректних адрес оброблятимуться так, як і "
"завантаження із повністю некоректних адрес: буде видано повідомлення щодо "
"помилки адресування, а байти-результати буде позначено як неініціалізовані.</"
"p><p>Зауважте, що код, який поводиться таким чином, порушує стандарти ISO C/C"
"++ і має вважатися помилковим. Якщо це можливо, слід виправляти такий "
"програмний код.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_partialLoadsOk)
#: tools/memcheck/memcheck_configpage.ui:176
#, kde-format
msgid "Allow partial loads"
msgstr "Дозволити часткові завантаження"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:183
#, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck tracks the origin of "
"uninitialised values. By default, it does not, which means that although it "
"can tell you that an uninitialised value is being used in a dangerous way, "
"it cannot tell you where the uninitialised value came from. This often makes "
"it difficult to track down the root problem.</p><p>When set to <span style="
"\" font-family:'Monospace'; font-weight:600; font-style:italic;\">yes</"
"span>, Memcheck keeps track of the origins of all uninitialised values. "
"Then, when an uninitialised value error is reported, Memcheck will try to "
"show the origin of the value. An origin can be one of the following four "
"places: a heap block, a stack allocation, a client request, or miscellaneous "
"other sources (eg, a call to <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">brk</span>).</p><p>For uninitialised values "
"originating from a heap block, Memcheck shows where the block was allocated. "
"For uninitialised values originating from a stack allocation, Memcheck can "
"tell you which function allocated the value, but no more than that -- "
"typically it shows you the source location of the opening brace of the "
"function. So you should carefully check that all of the function's local "
"variables are initialised properly. </p><p>Performance overhead: origin "
"tracking is expensive. It halves Memcheck's speed and increases memory use "
"by a minimum of 100MB, and possibly more. Nevertheless it can drastically "
"reduce the effort required to identify the root cause of uninitialised value "
"errors, and so is often a programmer productivity win, despite running more "
"slowly. </p><p>Accuracy: Memcheck tracks origins quite accurately. To avoid "
"very large space and time overheads, some approximations are made. It is "
"possible, although unlikely, that Memcheck will report an incorrect origin, "
"or not be able to identify any origin. </p><p>Note that the combination "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">--track-origins=yes</span> and <span style=\" font-family:'Monospace'; "
"font-weight:600; font-style:italic;\">--undef-value-errors=no</span> is "
"nonsensical. Memcheck checks for and rejects this combination at startup.</"
"p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи стежитиме Memcheck за походженням "
"неініціалізованих значень. Типово, програма цього не робить, що означає, що "
"хоча програма може повідомити вам, що у небезпечний спосіб використано "
"неініціалізоване значення, вона не зможе повідомити вам, звідки прийшло це "
"неініціалізоване значення. Це часто ускладнює визначення джерела проблеми.</"
"p><p>Якщо встановити значення <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">yes</span>, Memcheck стежитиме за "
"походженням усіх неініціалізованих значень. Таким чином, коли до звіту "
"потраплятиме повідомлення щодо помилки, пов’язаної із неініціалізованим "
"значенням, Memcheck намагатиметься показати дані щодо походження значення. "
"Походженням може бути одне з чотирьох місць: блок «купи», область розміщення "
"даних зі стека, клієнтський запит або різні інші джерела (наприклад виклик "
"<span style=\" font-family:'Monospace'; font-weight:600; font-style:italic;"
"\">brk</span>).</p><p>Для неініціалізованих значень зі блоку «купи» Memcheck "
"показує дані щодо того, де було отримано для розміщення цей блок. Для "
"неініціалізованих значень, що походять з області розміщення даних зі стека, "
"Memcheck може повідомити вам назву функції, яка розмістила значення, але не "
"більше — типово, програма показує вам розташування у коді початкової "
"фігурної дужки цієї функції. Отже, вам доведеться ретельно перевірити, чи "
"усі локальні змінні функції ініціалізовано належним чином.</p><p>Вплив на "
"швидкодію: визначення походження є доволі витратною операцією. Воно вдвічі "
"уповільнює роботу Memcheck і збільшує споживання пам’яті мінімум на 100 МБ, "
"а може й більше. Втім, воно надзвичайно зменшує зусилля, які потрібні на "
"визначення причини появи помилок щодо неініціалізованого значення, а отже, "
"часто зростає продуктивність програміста, хоча обробка даних триває довше.</"
"p><p>Точність: Memcheck визначає походження доволі точно. Для уникнення "
"надмірного впливу на спожитий об’єм пам’яті та навантаження процесора "
"використовуються певні наближення. Може так статися, хоча і з дуже низькою "
"ймовірністю, що Memcheck повідомить неправильні дані щодо походження або "
"взагалі не зможе визначити походження.</p><p>Зауважте, що поєднання <span "
"style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
"track-origins=yes</span> і <span style=\" font-family:'Monospace'; font-"
"weight:600; font-style:italic;\">--undef-value-errors=no</span> позбавлене "
"сенсу. Memcheck виявляє такі поєднання параметрів під час запуску і "
"відмовляється їх використовувати.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_trackOrigins)
#: tools/memcheck/memcheck_configpage.ui:186
#, kde-format
msgid "Track origins of all uninitialised values"
msgstr "Стежити за походженням усіх неініціалізованих значень"

#. i18n: ectx: property (toolTip), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:193
#, no-c-format, kde-format
msgid ""
"<html><head/><body><p>Controls whether Memcheck should employ more precise "
"but also more expensive (time consuming) algorithms when checking the "
"definedness of a value. The default setting is not to do that and it is "
"usually sufficient. However, for highly optimised code valgrind may "
"sometimes incorrectly complain. Invoking valgrind with <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--expensive-"
"definedness-checks=yes</span> helps but comes at a performance cost. Runtime "
"degradation of 25% have been observed but the extra cost depends a lot on "
"the application at hand.</p></body></html>"
msgstr ""
"<html><head/><body><p>Керує тим, чи слід Memcheck використовувати точніші, "
"але повільніші алгоритми під час перевірки визначеності значення. Типово, "
"такі алгоритми не використовуватимуться, оскільки, зазвичай, у цьому немає "
"потреби. Втім, для високооптимізованого коду valgrind може іноді помилково "
"повідомляти про помилки. Виклик valgrind з параметром <span style=\" font-"
"family:'Monospace'; font-weight:600; font-style:italic;\">--expensive-"
"definedness-checks=yes</span> допомагає, але сповільнює роботи програми. "
"Спостерігалося уповільнення до 25%. Вартість цієї перевірки залежить від "
"програми, яку ви вивчаєте.</p></body></html>"

#. i18n: ectx: property (text), widget (QCheckBox, kcfg_expensiveDefinednessChecks)
#: tools/memcheck/memcheck_configpage.ui:196
#, kde-format
msgid "Expensive definedness checks"
msgstr "Перевірки вартісних визначеностей"

#: tools/memcheck/memcheck_tool.cpp:35
#, kde-format
msgid "Memcheck"
msgstr "Перевірка витоку пам’яті"

#: tools/memcheck/memcheck_tool.cpp:36
#, kde-format
msgid "Memcheck (Memory Error Detector)"
msgstr "Memcheck (засіб виявлення помилок у роботі з пам’яттю)"

#: toolviewfactory.cpp:47
#, kde-format
msgid "Valgrind Output"
msgstr "Вивід Valgrind"

#: toolviewfactory.cpp:49
#, kde-format
msgid ""
"<b>Valgrind</b><p>Shows the output of valgrind. Valgrind detects:<br/>use of "
"uninitialized memory;<br/>reading/writing memory after it has been free'd;"
"<br/>reading/writing off the end of malloc'd blocks;<br/>reading/writing "
"inappropriate areas on the stack;<br/>memory leaks &mdash; where pointers to "
"malloc'd blocks are lost forever;<br/>passing of uninitialised and/or "
"unaddressable memory to system calls;<br/>mismatched use of malloc/new/new "
"[] vs free/delete/delete [];<br/>some abuses of the POSIX pthread API.</p>"
msgstr ""
"<b>Valgrind</b><p>Показує вивід valgrind. Valgrind виявляє:<br/>використання "
"не ініціалізованої пам’яті<br/>операції читання/запису з вивільненої "
"командою free пам’яті<br/>операції читання/запису за межами виділених "
"командою malloc блоків пам’яті<br/>операції читання/запису у не призначені "
"для цього області стека<br/>витоки пам’яті — ситуації, коли втрачено "
"вказівники на виділені командою malloc блоки пам’яті<br/>передачу не "
"ініціалізованої та/або не адресовної пам’яті системним викликам<br/"
">плутанину з використанням викликів malloc/new/new [x] та free/delete/delete "
"[x]<br/>порушення правил використання API pthread, обумовленого POSIX.</p>"

#~ msgid ""
#~ "<html><head/><body><p><span style=\" font-family:'Monospace'; font-"
#~ "weight:600; font-style:italic;\">--history-level=full</span> (the "
#~ "default) causes Helgrind collects enough information about \"old\" "
#~ "accesses that it can produce two stack traces in a race report -- both "
#~ "the stack trace for the current access, and the trace for the older, "
#~ "conflicting access. To limit memory usage, \"old\" accesses stack traces "
#~ "are limited to a maximum of 8 entries, even if <span style=\" font-"
#~ "family:'Monospace'; font-weight:600; font-style:italic;\">--num-callers</"
#~ "span> value is bigger.</p><p>Collecting such information is expensive in "
#~ "both speed and memory, particularly for programs that do many inter-"
#~ "thread synchronization events (locks, unlocks, etc). Without such "
#~ "information, it is more difficult to track down the root causes of races. "
#~ "Nonetheless, you may not need it in situations where you just want to "
#~ "check for the presence or absence of races, for example, when doing "
#~ "regression testing of a previously race-free program.</p><p><span style="
#~ "\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
#~ "history-level=none</span> is the opposite extreme. It causes Helgrind not "
#~ "to collect any information about previous accesses. This can be "
#~ "dramatically faster than <span style=\" font-family:'Monospace'; font-"
#~ "weight:600; font-style:italic;\">--history-level=full</span>.</p><p><span "
#~ "style=\" font-family:'Monospace'; font-weight:600; font-style:italic;\">--"
#~ "history-level=approx</span> provides a compromise between these two "
#~ "extremes. It causes Helgrind to show a full trace for the later access, "
#~ "and approximate information regarding the earlier access. This "
#~ "approximate information consists of two stacks, and the earlier access is "
#~ "guaranteed to have occurred somewhere between program points denoted by "
#~ "the two stacks. This is not as useful as showing the exact stack for the "
#~ "previous access (as <span style=\" font-family:'Monospace'; font-"
#~ "weight:600; font-style:italic;\">--history-level=full</span> does), but "
#~ "it is better than nothing, and it is almost as fast as <span style=\" "
#~ "font-family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
#~ "level=none</span>.</p></body></html>"
#~ msgstr ""
#~ "<html><head/><body><p>Використання <span style=\" font-"
#~ "family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
#~ "level=full</span> (типова поведінка) призводити до того, що Helgrind "
#~ "збирає достатньо інформації щодо «застарілих» доступів і може створювати "
#~ "два трасування стека у звіті щодо проблем із конкуренцією потоків — "
#~ "трасування стека для поточного доступу і трасування для застарілого "
#~ "доступу із конфліктами. Щоб обмежити використання пам’яті, «застарілі» "
#~ "трасування стека обмежено максимальною кількістю записів 8, навіть якщо "
#~ "значення <span style=\" font-family:'Monospace'; font-weight:600; font-"
#~ "style:italic;\">--num-callers</span> є більшим.</p><p>Збирання таких "
#~ "даних є витратним як із точки зору швидкості роботи, так і з точки зору "
#~ "використання пам’яті, зокрема для програм, у яких багато подій "
#~ "синхронізації потоків виконання (блокування, розблокування тощо). Без цих "
#~ "даних складніше визначити корінь проблем із конкуренцією. Втім, у цьому, "
#~ "можливо, і немає потреби, якщо ви просто хочете перевірити, чи є проблеми "
#~ "із конкуренцією, наприклад, виконуючи перевірку на регресії у програмі, "
#~ "де раніше таких проблем не було.</p><p>Використання <span style=\" font-"
#~ "family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
#~ "level=none</span> є протилежністю. Воно призводить до того, що Helgrind "
#~ "не збирає жодних даних щодо попередніх доступів. Це може фантастично "
#~ "пришвидшити роботу програми у порівнянні з <span style=\" font-"
#~ "family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
#~ "level=full</span>.</p><p><span style=\" font-family:'Monospace'; font-"
#~ "weight:600; font-style:italic;\">--history-level=approx</span> є "
#~ "компромісом між цими двома полюсами. Використання цього значення "
#~ "параметра призведе до того, що Helgrind показуватиме повне трасування для "
#~ "останнього доступу і приблизні дані щодо попереднього доступу. Ця "
#~ "приблизна інформація складається з двох стеків, а попередній доступ "
#~ "гарантовано мав статися десь між пунктами у програмі, які визначаються "
#~ "цими двома стеками. Цей варіант не є таким інформативним як показ повного "
#~ "стека для попереднього доступу (як у варіанті з <span style=\" font-"
#~ "family:'Monospace'; font-weight:600; font-style:italic;\">--history-"
#~ "level=full</span>), але це краще ніж нічого і майже так само швидко як у "
#~ "варіанті з <span style=\" font-family:'Monospace'; font-weight:600; font-"
#~ "style:italic;\">--history-level=none</span>.</p><p><br/></p></body></html>"

#~ msgid "full"
#~ msgstr "full"

#~ msgid ""
#~ "<html><head/><body><p>The time unit used for the profiling. There are "
#~ "three possibilities: </p><p><span style=\" font-weight:600;"
#~ "\">instructions</span> executed (i), which is good for most cases; </"
#~ "p><p>real (wallclock) time (ms, i.e. <span style=\" font-weight:600;"
#~ "\">milliseconds</span>), which is sometimes useful; </p><p>and <span "
#~ "style=\" font-weight:600;\">bytes</span> allocated/deallocated on the "
#~ "heap and/or stack (B), which is useful for very short-run programs, and "
#~ "for testing purposes, because it is the most reproducible across "
#~ "different machines.</p></body></html>"
#~ msgstr ""
#~ "<html><head/><body><p>Одиниця часу, яка використовуватиметься для "
#~ "профілювання. Передбачено три варіанти: </p><p>виконані <span style=\" "
#~ "font-weight:600;\">інструкції</span> (i), добрий вибір для більшості "
#~ "випадків;</p><p>справжній (годинниковий) час (ms, тобто <span style=\" "
#~ "font-weight:600;\">мілісекунди</span>), іноді корисно;</p><p>і заповнені "
#~ "або вивільнені <span style=\" font-weight:600;\">байти</span> у «купі» і/"
#~ "або стеку (B), корисно для програм, які виконуються дуже швидко, та для "
#~ "тестування, оскільки ця характеристика лишається більш-менш однаковою на "
#~ "різному обладнанні.</p></body></html>"

#~ msgid "%"
#~ msgstr "%"

#~ msgid "Cppcheck Settings"
#~ msgstr "Параметри Cppcheck"

#~ msgid "Callgrind view"
#~ msgstr "Перегляд callgrind"

#~| msgid "Valgrind executables"
#~ msgid "Valgrind Analyzer"
#~ msgstr "Аналізатор Valgrind"

#~ msgid "Valgrind Tools"
#~ msgstr "Інструменти Valgrind"

#~ msgctxt "@title:menu"
#~ msgid "Analyze"
#~ msgstr "Проаналізувати"

#~ msgid "Valgrind (Current Launch Configuration)"
#~ msgstr "Valgrind (поточні налаштування запуску)"

#~ msgid "Helpers executables"
#~ msgstr "Виконувані файли допоміжних засобів"

#~ msgid "Analyze application with Cachegrind"
#~ msgstr "Проаналізувати програму за допомогою Cachegrind"

#~ msgid "Analyze application with Callgrind"
#~ msgstr "Проаналізувати програму за допомогою Callgrind"

#~ msgid "Analyze application with DRD"
#~ msgstr "Проаналізувати програму за допомогою DRD"

#~ msgid "Conditional branches mispredicted"
#~ msgstr "Помилки передбачення розгалуження за умовами"

#~ msgid "Indirect branches mispredicted"
#~ msgstr "Помилки передбачення непрямих гілок"

#~ msgid "Analyze application with Helgrind"
#~ msgstr "Проаналізувати програму за допомогою Helgrind"

#~ msgid "Analyze application with Massif"
#~ msgstr "Проаналізувати програму за допомогою Massif"

#~ msgid "Analyze application with Memcheck"
#~ msgstr "Проаналізувати програму за допомогою Memcheck"

#~ msgid ""
#~ "No environment group specified, looks like a broken configuration, please "
#~ "check run configuration '%1'. Using default environment group."
#~ msgstr ""
#~ "Не вказано групу середовища, схоже, ви припустилися помилки під час "
#~ "налаштування, будь ласка, перевірте налаштування запуску «%1». Буде "
#~ "використано типову групу середовища."

#~ msgid "Unable to launch the process %1 (%2)"
#~ msgstr "Не вдалося запустити процес %1 (%2)"

#~ msgid "&Maximum frame stack size (bytes):"
#~ msgstr "&Максимальний розмір стека блоків даних (у байтах):"

#~ msgid ""
#~ "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
#~ "REC-html40/strict.dtd\">\n"
#~ "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/"
#~ "css\">\n"
#~ "p, li { white-space: pre-wrap; }\n"
#~ "</style></head><body style=\" font-family:'Cantarell'; font-size:11pt; "
#~ "font-weight:400; font-style:normal;\">\n"
#~ "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
#~ "right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-"
#~ "family:'Arial,Geneva,Helvetica,sans-serif'; font-size:medium; color:"
#~ "#202020;\">When disabled, the memory leak detector only shows "
#~ "\"definitely lost\" and \"possibly lost\" blocks.</span></p>\n"
#~ "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
#~ "right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-"
#~ "family:'Arial,Geneva,Helvetica,sans-serif'; font-size:medium; color:"
#~ "#202020;\">When enabled, the leak detector also shows \"reachable\" and "
#~ "\"indirectly lost\" blocks.</span></p></body></html>"
#~ msgstr ""
#~ "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/"
#~ "REC-html40/strict.dtd\">\n"
#~ "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/"
#~ "css\">\n"
#~ "p, li { white-space: pre-wrap; }\n"
#~ "</style></head><body style=\" font-family:'Cantarell'; font-size:11pt; "
#~ "font-weight:400; font-style:normal;\">\n"
#~ "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
#~ "right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-"
#~ "family:'Arial,Geneva,Helvetica,sans-serif'; font-size:medium; color:"
#~ "#202020;\">Якщо не позначено, засіб виявлення витоків пам’яті "
#~ "показуватиме лише «точно втрачені» та «можливо втрачені» блоки.</span></"
#~ "p>\n"
#~ "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-"
#~ "right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-"
#~ "family:'Arial,Geneva,Helvetica,sans-serif'; font-size:medium; color:"
#~ "#202020;\">Якщо позначено, засіб виявлення витоків пам’яті показуватиме "
#~ "також «досяжні» та «непрямо втрачені» блоки.</span></p></body></html>"

#~ msgid "Controls whether Memcheck reports uses of undefined value errors."
#~ msgstr ""
#~ "Визначає, чи повідомлятиме Memcheck про помилки у використанні "
#~ "невизначених значень."

#~ msgid "Undef value errors"
#~ msgstr "Помилки з невизначеними значеннями"

#~ msgid "Default valgrind tool:"
#~ msgstr "Типовий інструмент valgrind:"

#~ msgid "Form"
#~ msgstr "Форма"

#~ msgid "Percenage values"
#~ msgstr "Значення у відсотках"

#~ msgid "Ir (I cache read)"
#~ msgstr "Ir (читання кешу I)"

#~ msgid "I1mr (L1 cache read miss)"
#~ msgstr "I1mr (нестачі читання кешу L1)"

#~ msgid "ILmr (LL cache read miss)"
#~ msgstr "ILmr (нестачі читання кешу LL)"

#~ msgid "Dr (D cache read)"
#~ msgstr "Dr (читання кешу D)"

#~ msgid "D1mr (D1 cache read miss)"
#~ msgstr "D1mr (нестачі читання кешу D1)"

#~ msgid "DLmr (DL cache read miss)"
#~ msgstr "DLmr (нестачі читання кешу DL)"

#~ msgid "Dw (D cache write)"
#~ msgstr "Dw (запис кешу D)"

#~ msgid "D1mw (D1 cache write miss)"
#~ msgstr "D1mw (нестачі запису кешу D1)"

#~ msgid "DLmw (DL cache write miss)"
#~ msgstr "DLmw (нестачі запису кешу DL)"

#~ msgid "Call name"
#~ msgstr "Назва комірки"

#~ msgid "File name"
#~ msgstr "Назва файла"

#~ msgid "Program Totals"
#~ msgstr "Загальні дані для програми"

#~ msgid "Bcm (conditional branches mispredicted)"
#~ msgstr "Bcm (помилки передбачення розгалуження за умовами)"

#~ msgid "Bim (indirect branches mispredicted)"
#~ msgstr "Bim (помилки передбачення непрямих гілок)"

#~ msgid "Number of calls"
#~ msgstr "Кількість викликів"

#~ msgid "???"
#~ msgstr "???"

#~ msgid "Function Name"
#~ msgstr "Назва функції"

#~ msgid "Ir"
#~ msgstr "Ir"

#~ msgid "List of functions"
#~ msgstr "Список функцій"

#~ msgid "Show value as percentage"
#~ msgstr "Показувати значення у відсотках"

#~ msgid "I"
#~ msgstr "I"

#~ msgid "I1mr"
#~ msgstr "I1mr"

#~ msgid "ILmr"
#~ msgstr "ILmr"

#~ msgid "Dr"
#~ msgstr "Dr"

#~ msgid "D1mr"
#~ msgstr "D1mr"

#~ msgid "DLmr"
#~ msgstr "DLmr"

#~ msgid "Dw"
#~ msgstr "Dw"

#~ msgid "D1mw"
#~ msgstr "D1mw"

#~ msgid "DLmw"
#~ msgstr "DLmw"

#~ msgid "Bc"
#~ msgstr "Bc"

#~ msgid "Bcm"
#~ msgstr "Bcm"

#~ msgid "Bi"
#~ msgstr "Bi"

#~ msgid "Bim"
#~ msgstr "Bim"

#~ msgid "time"
#~ msgstr "час"

#~ msgid "mem_heap_B"
#~ msgstr "mem_heap_B"

#~ msgid "mem_heap_extra_B"
#~ msgstr "mem_heap_extra_B"

#~ msgid "mem_stacks_B"
#~ msgstr "mem_stacks_B"

#~ msgid "E&xtra valgrind parameters"
#~ msgstr "Д&одаткові параметри valgrind"

#~ msgid "&Valgrind Executable:"
#~ msgstr "В&иконуваний файл Valgrind:"

#~ msgid "KCachegrind Executable:"
#~ msgstr "Виконуваний файл KCachegrind:"

#~ msgid " %"
#~ msgstr " %"

#~ msgid "/usr/bin/kcachegrind"
#~ msgstr "/usr/bin/kcachegrind"

#~ msgid "Extra Synchronization Events:"
#~ msgstr "Додаткові події для синхронізації:"

#~ msgid "Separate Thread Reporting"
#~ msgstr "Розділити звіт за нитками"

#~ msgid "Full Cache Simulation"
#~ msgstr "Імітувати переповнення кешу"

#~ msgid "Simulate Hardware Prefetcher"
#~ msgstr "Імітувати апаратну вибірку з випередженням"

#~ msgid "Extra &Parameters:"
#~ msgstr "Додаткові &параметри:"

#~ msgid "Display stack to &depth:"
#~ msgstr "Показувати стек на &глибину:"

#~ msgid " bytes"
#~ msgstr " байтів"

#~ msgid ""
#~ "Whether or not to trace invalid frees (call to free on a non-allocated "
#~ "address)"
#~ msgstr ""
#~ "Чи слід визначати некоректні звільнення (виклики free для невиділеної "
#~ "адреси)"

#~ msgid "Show invalid frees"
#~ msgstr "Показувати некоректні звільнення"

#~ msgid ""
#~ "Whether or not to trace mismatched frees (for example, trying to call "
#~ "free on an area allocated with new)"
#~ msgstr ""
#~ "Чи слід визначати невідповідні звільнення (наприклад, спроби виклику free "
#~ "для областей, виділених за допомогою new)"

#~ msgid ""
#~ "Whether or not to trace invalid reads (dereferencing of a non-allocated "
#~ "address)"
#~ msgstr ""
#~ "Чи слід визначати некоректні читання (посилання на невиділені адреси)"

#~ msgid "Show invalid reads"
#~ msgstr "Показувати некоректні читання"

#~ msgid ""
#~ "Whether or not to trace invalid writes (writing to a non-allocated "
#~ "address)"
#~ msgstr ""
#~ "Чи слід визначати некоректні записи (записи за невиділеними адресами)"

#~ msgid "Show invalid writes"
#~ msgstr "Показувати некоректні записи"

#~ msgid ""
#~ "Whether or not to trace invalid jumps (call to an invalid pointer of "
#~ "function for example)"
#~ msgstr ""
#~ "Чи слід визначати некоректні переходи (наприклад, виклики некоректних "
#~ "вказівників функцій)"

#~ msgid "Show invalid jumps"
#~ msgstr "Показувати некоректні переходи"

#~ msgid "Show overlaps"
#~ msgstr "Показувати перекриття"

#~ msgid "Show invalid memory pools"
#~ msgstr "Показувати некоректні резервування у пам’яті"

#~ msgid "Show uninitialized conditions"
#~ msgstr "Показувати неініціалізовані умови"

#~ msgid "Show invalid syscall parameters"
#~ msgstr "Показувати некоректні параметри системних викликів"

#~ msgid "Show client checks"
#~ msgstr "Показувати перевірки клієнтів"

#~ msgid "Show definitely lost leaks"
#~ msgstr "Показувати витоки з безумовними втратами"

#~ msgid "Show indirectly lost leaks"
#~ msgstr "Показувати витоки через непрямі втрати"

#~ msgid "Show still reachable leaks"
#~ msgstr "Показувати ще доступні витоки"

#~ msgid "Show others"
#~ msgstr "Показувати інше"

#~ msgid "job scheduled"
#~ msgstr "завдання заплановано"

#~ msgid "job failed"
#~ msgstr "виконання завдання зазнало невдачі"

#~ msgid "job output (pid=%1)"
#~ msgstr "виведення завданням даних (pid=%1)"

#~ msgid "job running (pid=%1)"
#~ msgstr "виконання завдання (pid=%1)"

#~ msgid "Failed to start Valgrind"
#~ msgstr "Не вдалося запустити Valgrind"

#~ msgid "job finished (pid=%1,exit=%2)"
#~ msgstr "завдання виконано (pid=%1,exit=%2)"

#~ msgid "Socket error while communicating with valgrind: \"%1\""
#~ msgstr "Помилка гнізда під час обміну інформацією з valgrind: «%1»"

#~ msgid "Valgrind communication error"
#~ msgstr "Помилка під час обміну інформацією з Valgrind"

#~ msgid ""
#~ "Launches the currently selected launch configuration with the Valgrind "
#~ "presets"
#~ msgstr ""
#~ "Виконує програму на основі налаштування запуску за допомогою наборів "
#~ "тестів Valgrind."

#~ msgid "Valgrind launch"
#~ msgstr "Запуск Valgrind"

#~ msgctxt "@title:menu"
#~ msgid "Run"
#~ msgstr "Запустити"

#~ msgid "at %1: %2"
#~ msgstr "у %1: %2"

#~ msgid "by %1: %2"
#~ msgstr "від %1: %2"

#~ msgid "%1:%2"
#~ msgstr "%1:%2"

#~ msgid "Source"
#~ msgstr "Джерело"

#~ msgid "Object"
#~ msgstr "Об’єкт"

#~ msgctxt "NAME OF TRANSLATORS"
#~ msgid "Your names"
#~ msgstr "Юрій Чорноіван"

#~ msgctxt "EMAIL OF TRANSLATORS"
#~ msgid "Your emails"
#~ msgstr "yurchor@ukr.net"

#~ msgid "Support for running Valgrind"
#~ msgstr "Підтримка запуску Valgrind"

#~ msgid "Open Valgrind Output"
#~ msgstr "Відкрити вивід Valgrind"

#~ msgid "Could not open Valgrind output: %1"
#~ msgstr "Не вдалося відкрити вивід Valgrind: %1"

#~ msgctxt "@title:menu"
#~ msgid "Profile Launch (Valgrind)"
#~ msgstr "Запуск профілювання (Valgrind)"

#~ msgid "Limit &identical error display"
#~ msgstr "Обмежити відображення &ідентичних помилок"

#~ msgid "&Memcheck"
#~ msgstr "Перевірка витоку &пам’яті"

#~ msgid "Leak Summary:"
#~ msgstr "Резюме витоків:"

#~ msgid "Summary"
#~ msgstr "Зведення"

#~ msgid "High"
#~ msgstr "Висока"

#~ msgid "None (Locks Only)"
#~ msgstr "Жодні (лише замки)"

#~ msgid "Threads"
#~ msgstr "Нитки"

#~ msgid "All"
#~ msgstr "Всі"

#~ msgid "Call Tracing"
#~ msgstr "Трасування викликів"

#~ msgid "Memory Check"
#~ msgstr "Перевірка пам’яті"

#~ msgid ""
#~ "Launches the currently selected launch configuration with the Valgrind "
#~ "Call Tracing (callgrind)."
#~ msgstr ""
#~ "Виконує програму програму на основі налаштування запуску за допомогою "
#~ "інструмента трасування викликів Valgrind (callgrind)."

#~ msgid ""
#~ "Launches the currently selected launch configuration with the Valgrind "
#~ "Race Conditions Checker (helgrind)."
#~ msgstr ""
#~ "Виконує програму програму на основі налаштування запуску за допомогою "
#~ "інструмента перевірки конкуренції Valgrind (helgrind)."

#~ msgid ""
#~ "Launches the currently selected launch configuration with the Valgrind "
#~ "Cache Simulator (cachegrind)."
#~ msgstr ""
#~ "Виконує програму програму на основі налаштування запуску за допомогою "
#~ "інструмента імітації кешування Valgrind (cachegrind)."

#~ msgid "Installing via sudo is not yet implemented"
#~ msgstr "Встановлення за допомогою sudo ще не реалізовано"

#~ msgid "Not implemented"
#~ msgstr "Не реалізовано"

#~ msgid "&Valgrind Memory Leak Check"
#~ msgstr "Перевірка витоків пам’яті за допомогою &Valgrind"

#~ msgid "Valgrind memory leak check and other tools"
#~ msgstr ""
#~ "Перевірка витоків пам’яті за допомогою Valgrind та супутні інструменти"

#~ msgid ""
#~ "<b>Valgrind memory leak check</b><p>Runs Valgrind &mdash; a tool to help "
#~ "you find memory-management problems in your programs, and which provides "
#~ "other tools.</p>"
#~ msgstr ""
#~ "<b>Перевірка витоків пам’яті за допомогою Valgrind</b><p>Запускає "
#~ "Valgrind — допоміжний інструмент для пошуку проблем з організацією роботи "
#~ "з пам’яттю у ваших програмах, та інші супутні інструменти.</p>"

#~ msgid "No executable specified"
#~ msgstr "Не вказано виконуваного файла"

#~ msgid ""
#~ "There is a quoting error in the executable for the launch configuration "
#~ "'%1'. Aborting start."
#~ msgstr ""
#~ "Під час визначення виконуваного файла у налаштуваннях запуску виявлено "
#~ "помилку у використанні лапок «%1». Запуск перервано."

#~ msgid ""
#~ "A shell meta character was included in the executable for the launch "
#~ "configuration '%1', this is not supported currently. Aborting start."
#~ msgstr ""
#~ "У визначенні виконуваного файла налаштувань запуску було використано "
#~ "метасимвол оболонки «%1», підтримку таких символів ще не реалізовано. "
#~ "Запуск перервано."

#~ msgid ""
#~ "There is a quoting error in the arguments for the launch configuration "
#~ "'%1'. Aborting start."
#~ msgstr ""
#~ "Під час спроби виконання файла було виявлено помилку у використанні лапок "
#~ "у параметрах налаштуваннях запуску «%1». Запуск перервано."

#~ msgid ""
#~ "A shell meta character was included in the arguments for the launch "
#~ "configuration '%1', this is not supported currently. Aborting start."
#~ msgstr ""
#~ "У параметрах налаштуваннях запуску було використано метасимвол оболонки "
#~ "«%1», підтримку таких символів ще не реалізовано. Запуск перервано."

#~ msgid "&Executable:"
#~ msgstr "&Виконуваний файл:"

#~ msgid "&Parameters:"
#~ msgstr "&Параметри:"

#~ msgid "&Trace children"
#~ msgstr "&Трасувати процеси-нащадки"

#~ msgid "E&xecutable:"
#~ msgstr "&Виконуваний файл:"

#~ msgid "Additional p&arameters:"
#~ msgstr "Додаткові п&араметри:"

#~ msgid "KCacheGrind"
#~ msgstr "KCacheGrind"

#~ msgid "Valgrind (Memcheck)"
#~ msgstr "Valgrind (Перевірка витікань пам’яті)"

#~ msgid "Valgrind (Cachegrind)"
#~ msgstr "Valgrind (Перевірка кешу)"

#~ msgid "Valgrind (Helgrind)"
#~ msgstr "Valgrind (Helgrind)"

#~ msgid "Valgrind (DRD)"
#~ msgstr "Valgrind (DRD)"

#~ msgid "Valgrind (Omega)"
#~ msgstr "Valgrind (Omega)"

#~ msgid "Valgrind (Lackey)"
#~ msgstr "Valgrind (Lackey)"
